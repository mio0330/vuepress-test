<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <title>Title</title>-->
    <style>
        body {
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial !important;
}

.markdown-body {
    word-break: break-word;
    line-height: 1.75;
    font-weight: 400;
    font-size: 16px;
    overflow-x: hidden;
    color: #333
}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    line-height: 1.5;
    margin-top: 35px;
    margin-bottom: 10px;
    padding-bottom: 5px
}

.markdown-body h1 {
    font-size: 24px;
    margin-bottom: 5px
}

.markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    font-size: 20px
}

.markdown-body h2 {
    padding-bottom: 12px;
    border-bottom: 1px solid #ececec
}

.markdown-body h3 {
    font-size: 18px;
    padding-bottom: 0
}

.markdown-body h6 {
    margin-top: 5px
}

.markdown-body p {
    line-height: inherit;
    margin-top: 22px;
    margin-bottom: 22px
}

.markdown-body img {
    max-width: 100%
}

.markdown-body hr {
    border: none;
    border-top: 1px solid #ddd;
    margin-top: 32px;
    margin-bottom: 32px
}

.markdown-body code {
    word-break: break-word;
    border-radius: 2px;
    overflow-x: auto;
    background-color: #fff5f5;
    color: #ff502c;
    font-size: .87em;
    padding: .065em .4em
}

.markdown-body code, .markdown-body pre {
    font-family: Menlo, Monaco, Consolas, Courier New, monospace
}

.markdown-body pre {
    overflow: auto;
    position: relative;
    line-height: 1.75
}

.markdown-body pre > code {
    font-size: 12px;
    padding: 15px 12px;
    margin: 0;
    word-break: normal;
    display: block;
    overflow-x: auto;
    color: #333;
    background: #f8f8f8
}

.markdown-body a {
    text-decoration: none;
    color: #0269c8;
    border-bottom: 1px solid #d1e9ff
}

.markdown-body a:active, .markdown-body a:hover {
    color: #275b8c
}

.markdown-body table {
    display: inline-block !important;
    font-size: 12px;
    width: auto;
    max-width: 100%;
    overflow: auto;
    border: 1px solid #f6f6f6
}

.markdown-body thead {
    background: #f6f6f6;
    color: #000;
    text-align: left
}

.markdown-body tr:nth-child(2n) {
    background-color: #fcfcfc
}

.markdown-body td, .markdown-body th {
    padding: 12px 7px;
    line-height: 24px
}

.markdown-body td {
    min-width: 120px
}

.markdown-body blockquote {
    color: #666;
    padding: 1px 23px;
    margin: 22px 0;
    border-left: 4px solid #cbcbcb;
    background-color: #f8f8f8
}

.markdown-body blockquote:after {
    display: block;
    content: ""
}

.markdown-body blockquote > p {
    margin: 10px 0
}

.markdown-body ol, .markdown-body ul {
    padding-left: 28px
}

.markdown-body ol li, .markdown-body ul li {
    margin-bottom: 0;
    list-style: inherit
}

.markdown-body ol li .task-list-item, .markdown-body ul li .task-list-item {
    list-style: none
}

.markdown-body ol li .task-list-item ol, .markdown-body ol li .task-list-item ul, .markdown-body ul li .task-list-item ol, .markdown-body ul li .task-list-item ul {
    margin-top: 0
}

.markdown-body ol ol, .markdown-body ol ul, .markdown-body ul ol, .markdown-body ul ul {
    margin-top: 3px
}

.markdown-body ol li {
    padding-left: 6px
}

.markdown-body .contains-task-list {
    padding-left: 0
}

.markdown-body .task-list-item {
    list-style: none
}

@media (max-width: 720px) {
    .markdown-body h1 {
        font-size: 24px
    }

    .markdown-body h2 {
        font-size: 20px
    }

    .markdown-body h3 {
        font-size: 18px
    }
}
    </style>
</head>
<body>
<div class="markdown-body">
    <p>在上一章中，我们一起系统学习了 Vite 的实现源码，从配置解析、依赖预构建、插件流水线和 HMR 这几个方面带你完整的梳理了 Vite 的底层原理，那么，在本小节中，我们将进一步，用实际的代码来写一个迷你版的 Vite，主要实现 Vite 最核心的 no-bundle 构建服务。在学完本节之后，你不仅能够复习之前所介绍的各种原理，也能深入地理解代码层面的实现细节，拥有独立开发一个 no-bundle 构建工具的能力。</p>
<h2>实战概览</h2>
<p>相较于前面的小节，本小节(以及下一小节)的内容会比较难，手写的代码量也比较多(总共近一千行)。因此，在开始代码实战之前，我先给大家梳理一下需要完成的模块和功能，让大家有一个整体的认知:</p>
<ol>
<li>
<p>首先，我们会进行开发环境的搭建，安装必要的依赖，并搭建项目的构建脚本，同时完成 cli 工具的初始化代码。</p>
</li>
<li>
<p>然后我们正式开始实现<code>依赖预构建</code>的功能，通过 Esbuild 实现依赖扫描和依赖构建的功能。</p>
</li>
<li>
<p>接着开始搭建 Vite 的插件机制，也就是开发 <code>PluginContainer</code> 和 <code>PluginContext</code> 两个主要的对象。</p>
</li>
<li>
<p>搭建完插件机制之后，我们将会开发一系列的插件来实现 no-bundle 服务的编译构建能力，包括入口 HTML 处理、 TS/TSX/JS/TSX 编译、CSS 编译和静态资源处理。</p>
</li>
<li>
<p>最后，我们会实现一套系统化的模块热更新的能力，从搭建模块依赖图开始，逐步实现 HMR 服务端和客户端的开发。</p>
</li>
</ol>
<p><img src="img\ca4eaedb-ae61-11ed-bbb0-342eb7027b95.jpg" alt="image.png"></p>
<h2>搭建开发环境</h2>
<blockquote>
<p>注: 手写 Vite 项目的所有代码，我已经放到了小册的 Github 仓库中，<a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/mini-vite" target="_blank" rel="nofollow noopener noreferrer">点击查看</a>。</p>
</blockquote>
<p>首先，你可以执行<code>pnpm init -y</code>来初始化项目，然后安装一些必要的依赖，执行命令如下:</p>
<blockquote>
<p>对于各个依赖的具体作用，大家先不用纠结，我将会在后面使用到依赖的时候介绍。</p>
</blockquote>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 运行时依赖</span>
pnpm i cac chokidar connect debug es-<span class="hljs-variable language_">module</span>-lexer esbuild fs-extra magic-<span class="hljs-built_in">string</span> picocolors resolve rollup sirv ws -S

<span class="hljs-comment">// 开发环境依赖</span>
pnpm i <span class="hljs-meta">@types</span>/connect <span class="hljs-meta">@types</span>/debug <span class="hljs-meta">@types</span>/fs-extra <span class="hljs-meta">@types</span>/resolve <span class="hljs-meta">@types</span>/ws tsup
</code></pre>
<p>Vite 本身使用的是 Rollup 进行自身的打包，但之前给大家介绍的 tsup 也能够实现库打包的功能，并且内置 esbuild 进行提速，性能上更加强悍，因此在这里我们使用 tsup 进行项目的构建。</p>
<p>为了接入 tsup 打包功能，你需要在 package.json 中加入这些命令:</p>
<pre><code class="hljs language-ts"><span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"start"</span>: <span class="hljs-string">"tsup --watch"</span>,
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"tsup --minify"</span>
},
</code></pre>
<p>同时，你需要在项目根目录新建<code>tsconfig.json</code>和<code>tsup.config.ts</code>这两份配置文件，内容分别如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// tsconfig.json</span>
{
  <span class="hljs-string">"compilerOptions"</span>: {
    <span class="hljs-comment">// 支持 commonjs 模块的 default import，如 import path from 'path'</span>
    <span class="hljs-comment">// 否则只能通过 import * as path from 'path' 进行导入</span>
    <span class="hljs-string">"esModuleInterop"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"target"</span>: <span class="hljs-string">"ES2020"</span>,
    <span class="hljs-string">"moduleResolution"</span>: <span class="hljs-string">"node"</span>,
    <span class="hljs-string">"module"</span>: <span class="hljs-string">"ES2020"</span>,
    <span class="hljs-string">"strict"</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<pre><code class="hljs language-ts"><span class="hljs-comment">// tsup.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"tsup"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-comment">// 后续会增加 entry</span>
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">"src/node/cli.ts"</span>,
  },
  <span class="hljs-comment">// 产物格式，包含 esm 和 cjs 格式</span>
  <span class="hljs-attr">format</span>: [<span class="hljs-string">"esm"</span>, <span class="hljs-string">"cjs"</span>],
  <span class="hljs-comment">// 目标语法</span>
  <span class="hljs-attr">target</span>: <span class="hljs-string">"es2020"</span>,
  <span class="hljs-comment">// 生成 sourcemap</span>
  <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// 没有拆包的需求，关闭拆包能力</span>
  <span class="hljs-attr">splitting</span>: <span class="hljs-literal">false</span>,
});
</code></pre>
<p>接着新建 <code>src/node/cli.ts</code>文件，我们进行 cli 的初始化:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/cli.ts</span>
<span class="hljs-keyword">import</span> cac <span class="hljs-keyword">from</span> <span class="hljs-string">"cac"</span>;

<span class="hljs-keyword">const</span> cli = <span class="hljs-title function_">cac</span>();

<span class="hljs-comment">// [] 中的内容为可选参数，也就是说仅输入 `vite` 命令下会执行下面的逻辑</span>
cli
  .<span class="hljs-title function_">command</span>(<span class="hljs-string">"[root]"</span>, <span class="hljs-string">"Run the development server"</span>)
  .<span class="hljs-title function_">alias</span>(<span class="hljs-string">"serve"</span>)
  .<span class="hljs-title function_">alias</span>(<span class="hljs-string">"dev"</span>)
  .<span class="hljs-title function_">action</span>(<span class="hljs-keyword">async</span> () => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'测试 cli~'</span>);
  });

cli.<span class="hljs-title function_">help</span>();

cli.<span class="hljs-title function_">parse</span>();
</code></pre>
<p>现在你可以执行 <code>pnpm start</code> 来编译这个<code>mini-vite</code>项目，tsup 会生成产物目录<code>dist</code>，然后你可以新建<code>bin/mini-vite</code>文件来引用产物:</p>
<pre><code class="hljs language-ts"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-built_in">require</span>(<span class="hljs-string">"../dist/index.js"</span>);
</code></pre>
<p>同时，你需要在 package.json 中注册<code>mini-vite</code>命令，配置如下:</p>
<pre><code class="hljs language-ts">{
  <span class="hljs-string">"bin"</span>: {
    <span class="hljs-string">"mini-vite"</span>: <span class="hljs-string">"bin/mini-vite"</span>
  }
}
</code></pre>
<p>如此一来，我们就可以在业务项目中使用 <code>mini-vite</code> 这个命令了。在小册的 Github 仓库中我为你准备了一个示例的 <code>playground</code> 项目，你可以拿来进行测试，<a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/mini-vite/playground" target="_blank" rel="nofollow noopener noreferrer">点击查看项目</a>。</p>
<p>将 <code>playground</code> 项目放在 <code>mini-vite</code> 目录中，然后执行 <code>pnpm i</code>，由于项目的<code>dependencies</code>中已经声明了<code>mini-vite</code>:</p>
<pre><code class="hljs language-ts">{
  <span class="hljs-string">"devDependencies"</span>: {
    <span class="hljs-string">"mini-vite"</span>: <span class="hljs-string">'../'</span>
  }
}
</code></pre>
<p>那么<code>mini-vite</code>命令会自动安装到测试项目的<code>node_modules/.bin</code>目录中:</p>
<p><img src="img\ca7efd7b-ae61-11ed-89cc-342eb7027b95.jpg" alt="image.png"></p>
<p>接着我们在<code>playground</code>项目中执行<code>pnpm dev</code>命令(内部执行<code>mini-vite</code>)，可以看到如下的 log 信息:</p>
<pre><code class="hljs">测试 cli~
</code></pre>
<p>接着，我们把<code>console.log</code>语句换成服务启动的逻辑:</p>
<pre><code class="hljs language-diff">import cac from "cac";
<span class="hljs-addition">+ import { startDevServer } from "./server";</span>

const cli = cac();

cli
  .command("[root]", "Run the development server")
  .alias("serve")
  .alias("dev")
  .action(async () => {
<span class="hljs-deletion">-    console.log('测试 cli~');</span>
<span class="hljs-addition">+    await startDevServer();</span>
  });
</code></pre>
<p>现在你需要新建<code>src/node/server/index.ts</code>，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// connect 是一个具有中间件机制的轻量级 Node.js 框架。</span>
<span class="hljs-comment">// 既可以单独作为服务器，也可以接入到任何具有中间件机制的框架中，如 Koa、Express</span>
<span class="hljs-keyword">import</span> connect <span class="hljs-keyword">from</span> <span class="hljs-string">"connect"</span>;
<span class="hljs-comment">// picocolors 是一个用来在命令行显示不同颜色文本的工具</span>
<span class="hljs-keyword">import</span> { blue, green } <span class="hljs-keyword">from</span> <span class="hljs-string">"picocolors"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">startDevServer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">connect</span>();
  <span class="hljs-keyword">const</span> root = process.<span class="hljs-title function_">cwd</span>();
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">async</span> () => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
      <span class="hljs-title function_">green</span>(<span class="hljs-string">"🚀 No-Bundle 服务已经成功启动!"</span>),
      <span class="hljs-string">`耗时: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now() - startTime}</span>ms`</span>
    );
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`> 本地访问路径: <span class="hljs-subst">${blue(<span class="hljs-string">"http://localhost:3000"</span>)}</span>`</span>);
  });
}
</code></pre>
<p>再次执行<code>pnpm dev</code>，你可以发现终端出现如下的启动日志:</p>
<p><img src="img\caa3d8f6-ae61-11ed-bc7b-342eb7027b95.jpg" alt="image.png"></p>
<p>OK，<code>mini-vite</code> 的 cli 功能和服务启动的逻辑目前就已经成功搭建起来了。</p>
<h2>依赖预构建</h2>
<p>现在我们来进入依赖预构建阶段的开发。</p>
<p>首先我们新建<code>src/node/optimizer/index.ts</code>来存放依赖预构建的逻辑:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">optimize</span>(<span class="hljs-params">root: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-comment">// 1. 确定入口</span>
  <span class="hljs-comment">// 2. 从入口处扫描依赖</span>
  <span class="hljs-comment">// 3. 预构建依赖</span>
}
</code></pre>
<p>然后在服务入口中引入预构建的逻辑:</p>
<pre><code class="hljs language-diff">// src/node/server/index.ts
import connect from "connect";
import { blue, green } from "picocolors";
<span class="hljs-addition">+ import { optimize } from "../optimizer/index";</span>

export async function startDevServer() {
  const app = connect();
  const root = process.cwd();
  const startTime = Date.now();
  app.listen(3000, async () => {
<span class="hljs-addition">+   await optimize(root);</span>

    console.log(
      green("🚀 No-Bundle 服务已经成功启动!"),
      `耗时: ${Date.now() - startTime}ms`
    );
    console.log(`> 本地访问路径: ${blue("http://localhost:3000")}`);
  });
}
</code></pre>
<p>接着我们来开发依赖预构建的功能，从上面的代码注释你也可以看出，我们需要完成三部分的逻辑:</p>
<ul>
<li>确定预构建入口</li>
<li>从入口开始扫描出用到的依赖</li>
<li>对依赖进行预构建</li>
</ul>
<p>首先是确定入口，为了方便理解，这里我直接约定为 src 目录下的<code>main.tsx</code>文件:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 需要引入的依赖</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-comment">// 1. 确定入口</span>
<span class="hljs-keyword">const</span> entry = path.<span class="hljs-title function_">resolve</span>(root, <span class="hljs-string">"src/main.tsx"</span>);
</code></pre>
<p>第二步是扫描依赖:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 需要引入的依赖 </span>
<span class="hljs-keyword">import</span> { build } <span class="hljs-keyword">from</span> <span class="hljs-string">"esbuild"</span>;
<span class="hljs-keyword">import</span> { green } <span class="hljs-keyword">from</span> <span class="hljs-string">"picocolors"</span>;
<span class="hljs-keyword">import</span> { scanPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">"./scanPlugin"</span>;

<span class="hljs-comment">// 2. 从入口处扫描依赖</span>
<span class="hljs-keyword">const</span> deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>&#x3C;<span class="hljs-built_in">string</span>>();
<span class="hljs-keyword">await</span> <span class="hljs-title function_">build</span>({
  <span class="hljs-attr">entryPoints</span>: [entry],
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">write</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">scanPlugin</span>(deps)],
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
<span class="hljs-string">`<span class="hljs-subst">${green(<span class="hljs-string">"需要预构建的依赖"</span>)}</span>:\n<span class="hljs-subst">${[...deps]
  .map(green)
  .map((item) => <span class="hljs-string">`  <span class="hljs-subst">${item}</span>`</span>)
  .join(<span class="hljs-string">"\n"</span>)}</span>`</span>
);
</code></pre>
<p>依赖扫描需要我们借助 Esbuild 插件来完成，最后会记录到 deps 这个集合中。接下来我们来着眼于 Esbuild 依赖扫描插件的开发，你需要在<code>optimzier</code>目录中新建<code>scanPlguin.ts</code>文件，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/optimizer/scanPlugin.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"esbuild"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">BARE_IMPORT_RE</span>, <span class="hljs-variable constant_">EXTERNAL_TYPES</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scanPlugin</span>(<span class="hljs-params">deps: <span class="hljs-built_in">Set</span>&#x3C;<span class="hljs-built_in">string</span>></span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"esbuild:scan-deps"</span>,
    <span class="hljs-title function_">setup</span>(<span class="hljs-params">build</span>) {
      <span class="hljs-comment">// 忽略的文件类型</span>
      build.<span class="hljs-title function_">onResolve</span>(
        { <span class="hljs-attr">filter</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`\\.(<span class="hljs-subst">${EXTERNAL_TYPES.join(<span class="hljs-string">"|"</span>)}</span>)$`</span>) },
        <span class="hljs-function">(<span class="hljs-params">resolveInfo</span>) =></span> {
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">path</span>: resolveInfo.<span class="hljs-property">path</span>,
            <span class="hljs-comment">// 打上 external 标记</span>
            <span class="hljs-attr">external</span>: <span class="hljs-literal">true</span>,
          };
        }
      );
      <span class="hljs-comment">// 记录依赖</span>
      build.<span class="hljs-title function_">onResolve</span>(
        {
          <span class="hljs-attr">filter</span>: <span class="hljs-variable constant_">BARE_IMPORT_RE</span>,
        },
        <span class="hljs-function">(<span class="hljs-params">resolveInfo</span>) =></span> {
          <span class="hljs-keyword">const</span> { <span class="hljs-attr">path</span>: id } = resolveInfo;
          <span class="hljs-comment">// 推入 deps 集合中</span>
          deps.<span class="hljs-title function_">add</span>(id);
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">path</span>: id,
            <span class="hljs-attr">external</span>: <span class="hljs-literal">true</span>,
          };
        }
      );
    },
  };
}
</code></pre>
<p>需要说明的是，文件中用到了一些常量，在<code>src/node/constants.ts</code>中定义，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">EXTERNAL_TYPES</span> = [
  <span class="hljs-string">"css"</span>,
  <span class="hljs-string">"less"</span>,
  <span class="hljs-string">"sass"</span>,
  <span class="hljs-string">"scss"</span>,
  <span class="hljs-string">"styl"</span>,
  <span class="hljs-string">"stylus"</span>,
  <span class="hljs-string">"pcss"</span>,
  <span class="hljs-string">"postcss"</span>,
  <span class="hljs-string">"vue"</span>,
  <span class="hljs-string">"svelte"</span>,
  <span class="hljs-string">"marko"</span>,
  <span class="hljs-string">"astro"</span>,
  <span class="hljs-string">"png"</span>,
  <span class="hljs-string">"jpe?g"</span>,
  <span class="hljs-string">"gif"</span>,
  <span class="hljs-string">"svg"</span>,
  <span class="hljs-string">"ico"</span>,
  <span class="hljs-string">"webp"</span>,
  <span class="hljs-string">"avif"</span>,
];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BARE_IMPORT_RE</span> = <span class="hljs-regexp">/^[\w@][^:]/</span>;
</code></pre>
<p>插件的逻辑非常简单，即把一些无关的资源进行 external，不让 esbuild 处理，防止 Esbuild 报错，同时将<code>bare import</code>的路径视作第三方包，推入 deps 集合中。</p>
<p>现在，我们在<code>playground</code>项目根路径中执行<code>pnpm dev</code>，可以发现依赖扫描已经成功执行:</p>
<p><img src="img\cac0b262-ae61-11ed-a0e2-342eb7027b95.jpg" alt="image.png"></p>
<p>当我们收集到所有的依赖信息之后，就可以对每个依赖进行打包，完成依赖预构建了:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/optimizer/index.ts</span>
<span class="hljs-comment">// 需要引入的依赖</span>
<span class="hljs-keyword">import</span> { preBundlePlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">"./preBundlePlugin"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">PRE_BUNDLE_DIR</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants"</span>;

<span class="hljs-comment">// 3. 预构建依赖</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">build</span>({
  <span class="hljs-attr">entryPoints</span>: [...deps],
  <span class="hljs-attr">write</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">format</span>: <span class="hljs-string">"esm"</span>,
  <span class="hljs-attr">splitting</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">outdir</span>: path.<span class="hljs-title function_">resolve</span>(root, <span class="hljs-variable constant_">PRE_BUNDLE_DIR</span>),
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">preBundlePlugin</span>(deps)],
});
</code></pre>
<p>在此，我们引入了一个新的常量<code>PRE_BUNDLE_DIR</code>，定义如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/constants.ts</span>
<span class="hljs-comment">// 增加如下代码</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-comment">// 预构建产物默认存放在 node_modules 中的 .m-vite 目录中</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRE_BUNDLE_DIR</span> = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">"node_modules"</span>, <span class="hljs-string">".m-vite"</span>);
</code></pre>
<p>接着，我们继续开发预构建的 Esbuild 插件。首先，考虑到兼容 Windows 系统，我们先加入一段工具函数的代码:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/utils.ts</span>
<span class="hljs-keyword">import</span> os <span class="hljs-keyword">from</span> <span class="hljs-string">"os"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">slash</span>(<span class="hljs-params">p: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">return</span> p.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">"/"</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isWindows = os.<span class="hljs-title function_">platform</span>() === <span class="hljs-string">"win32"</span>;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizePath</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">return</span> path.<span class="hljs-property">posix</span>.<span class="hljs-title function_">normalize</span>(isWindows ? <span class="hljs-title function_">slash</span>(id) : id);
}
</code></pre>
<p>然后完善预构建的代码:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Loader</span>, <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"esbuild"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">BARE_IMPORT_RE</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants"</span>;
<span class="hljs-comment">// 用来分析 es 模块 import/export 语句的库</span>
<span class="hljs-keyword">import</span> { init, parse } <span class="hljs-keyword">from</span> <span class="hljs-string">"es-module-lexer"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-comment">// 一个实现了 node 路径解析算法的库</span>
<span class="hljs-keyword">import</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">"resolve"</span>;
<span class="hljs-comment">// 一个更加好用的文件操作库</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;
<span class="hljs-comment">// 用来开发打印 debug 日志的库</span>
<span class="hljs-keyword">import</span> createDebug <span class="hljs-keyword">from</span> <span class="hljs-string">"debug"</span>;
<span class="hljs-keyword">import</span> { normalizePath } <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils"</span>;

<span class="hljs-keyword">const</span> debug = <span class="hljs-title function_">createDebug</span>(<span class="hljs-string">"dev"</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">preBundlePlugin</span>(<span class="hljs-params">deps: <span class="hljs-built_in">Set</span>&#x3C;<span class="hljs-built_in">string</span>></span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"esbuild:pre-bundle"</span>,
    <span class="hljs-title function_">setup</span>(<span class="hljs-params">build</span>) {
      build.<span class="hljs-title function_">onResolve</span>(
        {
          <span class="hljs-attr">filter</span>: <span class="hljs-variable constant_">BARE_IMPORT_RE</span>,
        },
        <span class="hljs-function">(<span class="hljs-params">resolveInfo</span>) =></span> {
          <span class="hljs-keyword">const</span> { <span class="hljs-attr">path</span>: id, importer } = resolveInfo;
          <span class="hljs-keyword">const</span> isEntry = !importer;
          <span class="hljs-comment">// 命中需要预编译的依赖</span>
          <span class="hljs-keyword">if</span> (deps.<span class="hljs-title function_">has</span>(id)) {
            <span class="hljs-comment">// 若为入口，则标记 dep 的 namespace</span>
            <span class="hljs-keyword">return</span> isEntry
              ? {
                  <span class="hljs-attr">path</span>: id,
                  <span class="hljs-attr">namespace</span>: <span class="hljs-string">"dep"</span>,
                }
              : {
                  <span class="hljs-comment">// 因为走到 onResolve 了，所以这里的 path 就是绝对路径了</span>
                  <span class="hljs-attr">path</span>: resolve.<span class="hljs-title function_">sync</span>(id, { <span class="hljs-attr">basedir</span>: process.<span class="hljs-title function_">cwd</span>() }),
                };
          }
        }
      );

      <span class="hljs-comment">// 拿到标记后的依赖，构造代理模块，交给 esbuild 打包</span>
      build.<span class="hljs-title function_">onLoad</span>(
        {
          <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/.*/</span>,
          <span class="hljs-attr">namespace</span>: <span class="hljs-string">"dep"</span>,
        },
        <span class="hljs-keyword">async</span> (loadInfo) => {
          <span class="hljs-keyword">await</span> init;
          <span class="hljs-keyword">const</span> id = loadInfo.<span class="hljs-property">path</span>;
          <span class="hljs-keyword">const</span> root = process.<span class="hljs-title function_">cwd</span>();
          <span class="hljs-keyword">const</span> entryPath = <span class="hljs-title function_">normalizePath</span>(resolve.<span class="hljs-title function_">sync</span>(id, { <span class="hljs-attr">basedir</span>: root }));
          <span class="hljs-keyword">const</span> code = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(entryPath, <span class="hljs-string">"utf-8"</span>);
          <span class="hljs-keyword">const</span> [imports, <span class="hljs-built_in">exports</span>] = <span class="hljs-keyword">await</span> <span class="hljs-title function_">parse</span>(code);
          <span class="hljs-keyword">let</span> proxyModule = [];
          <span class="hljs-comment">// cjs</span>
          <span class="hljs-keyword">if</span> (!imports.<span class="hljs-property">length</span> &#x26;&#x26; !<span class="hljs-built_in">exports</span>.<span class="hljs-property">length</span>) {
            <span class="hljs-comment">// 构造代理模块</span>
            <span class="hljs-comment">// 下面的代码后面会解释</span>
            <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">require</span>(entryPath);
            <span class="hljs-keyword">const</span> specifiers = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(res);
            proxyModule.<span class="hljs-title function_">push</span>(
              <span class="hljs-string">`export { <span class="hljs-subst">${specifiers.join(<span class="hljs-string">","</span>)}</span> } from "<span class="hljs-subst">${entryPath}</span>"`</span>,
              <span class="hljs-string">`export default require("<span class="hljs-subst">${entryPath}</span>")`</span>
            );
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// esm 格式比较好处理，export * 或者 export default 即可</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exports</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"default"</span>)) {
              proxyModule.<span class="hljs-title function_">push</span>(<span class="hljs-string">`import d from "<span class="hljs-subst">${entryPath}</span>";export default d`</span>);
            }
            proxyModule.<span class="hljs-title function_">push</span>(<span class="hljs-string">`export * from "<span class="hljs-subst">${entryPath}</span>"`</span>);
          }
          <span class="hljs-title function_">debug</span>(<span class="hljs-string">"代理模块内容: %o"</span>, proxyModule.<span class="hljs-title function_">join</span>(<span class="hljs-string">"\n"</span>));
          <span class="hljs-keyword">const</span> loader = path.<span class="hljs-title function_">extname</span>(entryPath).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">loader</span>: loader <span class="hljs-keyword">as</span> <span class="hljs-title class_">Loader</span>,
            <span class="hljs-attr">contents</span>: proxyModule.<span class="hljs-title function_">join</span>(<span class="hljs-string">"\n"</span>),
            <span class="hljs-attr">resolveDir</span>: root,
          };
        }
      );
    },
  };
}
</code></pre>
<p>值得一提的是，对于 CommonJS 格式的依赖，单纯用 <code>export default require('入口路径')</code> 是有局限性的，比如对于 React 而言，用这样的方式生成的产物最后只有 default 导出:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// esbuild 的打包产物</span>
<span class="hljs-comment">// 省略大部分代码</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> react_default;
</code></pre>
<p>那么用户在使用这个依赖的时候，必须这么使用:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// ✅ 正确</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> { useState } = <span class="hljs-title class_">React</span>;

<span class="hljs-comment">// ❌ 报错</span>
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
</code></pre>
<p>那为什么上述会报错的语法在 Vite 是可以正常使用的呢？原因是 Vite 在做 import 语句分析的时候，自动将你的代码进行改写了:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 原来的写法</span>
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-comment">// Vite 的 importAnalysis 插件转换后的写法类似下面这样</span>
<span class="hljs-keyword">import</span> react_default <span class="hljs-keyword">from</span> <span class="hljs-string">'/node_modules/.vite/react.js'</span>;

<span class="hljs-keyword">const</span> { useState } = react_default;
</code></pre>
<p>那么，还有没有别的方案来解决这个问题？没错，上述的插件代码中已经用另一个方案解决了这个问题，我们不妨把目光集中在下面这段代码中:</p>
<pre><code class="hljs language-ts">  <span class="hljs-keyword">if</span> (!imports.<span class="hljs-property">length</span> &#x26;&#x26; !<span class="hljs-built_in">exports</span>.<span class="hljs-property">length</span>) {
    <span class="hljs-comment">// 构造代理模块</span>
    <span class="hljs-comment">// 通过 require 拿到模块的导出对象</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">require</span>(entryPath);
    <span class="hljs-comment">// 用 Object.keys 拿到所有的具名导出</span>
    <span class="hljs-keyword">const</span> specifiers = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(res);
    <span class="hljs-comment">// 构造 export 语句交给 Esbuild 打包</span>
    proxyModule.<span class="hljs-title function_">push</span>(
      <span class="hljs-string">`export { <span class="hljs-subst">${specifiers.join(<span class="hljs-string">","</span>)}</span> } from "<span class="hljs-subst">${entryPath}</span>"`</span>,
      <span class="hljs-string">`export default require("<span class="hljs-subst">${entryPath}</span>")`</span>
    );
  }
</code></pre>
<p>如此一来，Esbuild 预构建的产物中便会包含 CommonJS 模块中所有的导出信息:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 预构建产物导出代码</span>
<span class="hljs-keyword">export</span> {
  react_default <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>,
  useState,
  useEffect,
  <span class="hljs-comment">// 省略其它导出</span>
}
</code></pre>
<p>OK，接下来让我们来测试一下预构建整体的功能。在 <code>playground</code> 项目中执行 <code>pnpm dev</code>，接着去项目的 <code>node_modules</code> 目录中，可以发现新增了<code>.m-vite</code> 目录及<code>react</code>、<code>react-dom</code>的预构建产物:</p>
<p><img src="img\cada8e80-ae61-11ed-a129-342eb7027b95.jpg" alt="image.png"></p>
<h2>插件机制开发</h2>
<p>在完成了依赖预构建的功能之后，我们开始搭建 Vite 的插件机制，实现插件容器和插件上下文对象。</p>
<p>首先，你可以新建<code>src/node/pluginContainer.ts</code>文件，增加如下的类型定义:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {
  <span class="hljs-title class_">LoadResult</span>,
  <span class="hljs-title class_">PartialResolvedId</span>,
  <span class="hljs-title class_">SourceDescription</span>,
  <span class="hljs-title class_">PluginContext</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">RollupPluginContext</span>,
  <span class="hljs-title class_">ResolvedId</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"rollup"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PluginContainer</span> {
  <span class="hljs-title function_">resolveId</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, importer?: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">PartialResolvedId</span> | <span class="hljs-literal">null</span>>;
  <span class="hljs-title function_">load</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">LoadResult</span> | <span class="hljs-literal">null</span>>;
  <span class="hljs-title function_">transform</span>(<span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">SourceDescription</span> | <span class="hljs-literal">null</span>>;
}
</code></pre>
<p>另外，由于插件容器需要接收 Vite 插件作为初始化参数，因此我们需要提前声明插件的类型，你可以继续新建<code>src/node/plugin.ts</code>来声明如下的插件类型:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LoadResult</span>, <span class="hljs-title class_">PartialResolvedId</span>, <span class="hljs-title class_">SourceDescription</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"rollup"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./server"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ServerHook</span> = <span class="hljs-function">(<span class="hljs-params">
  server: ServerContext
</span>) =></span> (<span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>) | <span class="hljs-built_in">void</span> | <span class="hljs-title class_">Promise</span>&#x3C;(<span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>) | <span class="hljs-built_in">void</span>>;

<span class="hljs-comment">// 只实现以下这几个钩子</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  configureServer?: <span class="hljs-title class_">ServerHook</span>;
  resolveId?: <span class="hljs-function">(<span class="hljs-params">
    id: <span class="hljs-built_in">string</span>,
    importer?: <span class="hljs-built_in">string</span>
  </span>) =></span> <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">PartialResolvedId</span> | <span class="hljs-literal">null</span>> | <span class="hljs-title class_">PartialResolvedId</span> | <span class="hljs-literal">null</span>;
  load?: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">LoadResult</span> | <span class="hljs-literal">null</span>> | <span class="hljs-title class_">LoadResult</span> | <span class="hljs-literal">null</span>;
  transform?: <span class="hljs-function">(<span class="hljs-params">
    code: <span class="hljs-built_in">string</span>,
    id: <span class="hljs-built_in">string</span>
  </span>) =></span> <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">SourceDescription</span> | <span class="hljs-literal">null</span>> | <span class="hljs-title class_">SourceDescription</span> | <span class="hljs-literal">null</span>;
  transformIndexHtml?: <span class="hljs-function">(<span class="hljs-params">raw: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-built_in">string</span>> | <span class="hljs-built_in">string</span>;
}
</code></pre>
<p>对于其中的 ServerContext，你暂时不用过于关心，只需要在<code>server/index.ts</code>中简单声明一下类型即可:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/server/index.ts</span>
<span class="hljs-comment">// 增加如下类型声明</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServerContext</span> {}
</code></pre>
<p>接着，我们来实现插件机制的具体逻辑，主要集中在<code>createPluginContainer</code>函数中:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/pluginContainer.ts</span>
<span class="hljs-comment">// 模拟 Rollup 的插件机制</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createPluginContainer = (<span class="hljs-attr">plugins</span>: <span class="hljs-title class_">Plugin</span>[]): <span class="hljs-function"><span class="hljs-params">PluginContainer</span> =></span> {
  <span class="hljs-comment">// 插件上下文对象</span>
  <span class="hljs-comment">// @ts-ignore 这里仅实现上下文对象的 resolve 方法</span>
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RollupPluginContext</span> {
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, importer?: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">let</span> out = <span class="hljs-keyword">await</span> pluginContainer.<span class="hljs-title function_">resolveId</span>(id, importer);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> out === <span class="hljs-string">"string"</span>) out = { <span class="hljs-attr">id</span>: out };
      <span class="hljs-keyword">return</span> out <span class="hljs-keyword">as</span> <span class="hljs-title class_">ResolvedId</span> | <span class="hljs-literal">null</span>;
    }
  }
  <span class="hljs-comment">// 插件容器</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">pluginContainer</span>: <span class="hljs-title class_">PluginContainer</span> = {
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">resolveId</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, importer?: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> plugin <span class="hljs-keyword">of</span> plugins) {
        <span class="hljs-keyword">if</span> (plugin.<span class="hljs-property">resolveId</span>) {
          <span class="hljs-keyword">const</span> newId = <span class="hljs-keyword">await</span> plugin.<span class="hljs-property">resolveId</span>.<span class="hljs-title function_">call</span>(ctx <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, id, importer);
          <span class="hljs-keyword">if</span> (newId) {
            id = <span class="hljs-keyword">typeof</span> newId === <span class="hljs-string">"string"</span> ? newId : newId.<span class="hljs-property">id</span>;
            <span class="hljs-keyword">return</span> { id };
          }
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">id</span>) {
      <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> plugin <span class="hljs-keyword">of</span> plugins) {
        <span class="hljs-keyword">if</span> (plugin.<span class="hljs-property">load</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> plugin.<span class="hljs-property">load</span>.<span class="hljs-title function_">call</span>(ctx, id);
          <span class="hljs-keyword">if</span> (result) {
            <span class="hljs-keyword">return</span> result;
          }
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> plugin <span class="hljs-keyword">of</span> plugins) {
        <span class="hljs-keyword">if</span> (plugin.<span class="hljs-property">transform</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> plugin.<span class="hljs-property">transform</span>.<span class="hljs-title function_">call</span>(ctx, code, id);
          <span class="hljs-keyword">if</span> (!result) <span class="hljs-keyword">continue</span>;
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">"string"</span>) {
            code = result;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.<span class="hljs-property">code</span>) {
            code = result.<span class="hljs-property">code</span>;
          }
        }
      }
      <span class="hljs-keyword">return</span> { code };
    },
  };

  <span class="hljs-keyword">return</span> pluginContainer;
};
</code></pre>
<p>上面的代码比较容易理解，并且关于插件钩子的执行原理和插件上下文对象的作用，在小册第 22 节中也有详细的分析，这里就不再赘述了。</p>
<p>接着，我们来完善一下之前的服务器逻辑:</p>
<pre><code class="hljs language-diff">// src/node/server/index.ts
import connect from "connect";
import { blue, green } from "picocolors";
import { optimize } from "../optimizer/index";
<span class="hljs-addition">+ import { resolvePlugins } from "../plugins";</span>
<span class="hljs-addition">+ import { createPluginContainer, PluginContainer } from "../pluginContainer";</span>

export interface ServerContext {
<span class="hljs-addition">+  root: string;</span>
<span class="hljs-addition">+  pluginContainer: PluginContainer;</span>
<span class="hljs-addition">+  app: connect.Server;</span>
<span class="hljs-addition">+  plugins: Plugin[];</span>
}

export async function startDevServer() {
  const app = connect();
  const root = process.cwd();
  const startTime = Date.now();
<span class="hljs-addition">+  const plugins = resolvePlugins();</span>
<span class="hljs-addition">+  const pluginContainer = createPluginContainer(plugins);</span>

<span class="hljs-addition">+  const serverContext: ServerContext = {</span>
<span class="hljs-addition">+    root: process.cwd(),</span>
<span class="hljs-addition">+    app,</span>
<span class="hljs-addition">+    pluginContainer,</span>
<span class="hljs-addition">+    plugins,</span>
<span class="hljs-addition">+  };</span>

<span class="hljs-addition">+  for (const plugin of plugins) {</span>
<span class="hljs-addition">+    if (plugin.configureServer) {</span>
<span class="hljs-addition">+      await plugin.configureServer(serverContext);</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+  }</span>

  app.listen(3000, async () => {
    await optimize(root);
    console.log(
      green("🚀 No-Bundle 服务已经成功启动!"),
      `耗时: ${Date.now() - startTime}ms`
    );
    console.log(`> 本地访问路径: ${blue("http://localhost:3000")}`);
  });
}
</code></pre>
<p>其中 <code>resolvePlugins</code> 方法我们还未定义，你可以新建<code>src/node/plugins/index.ts</code> 文件，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../plugin"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePlugins</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Plugin</span>[] {
  <span class="hljs-comment">// 下一部分会逐个补充插件逻辑</span>
  <span class="hljs-keyword">return</span> [];
}
</code></pre>
<h2>入口 HTML 加载</h2>
<p>现在我们基于如上的插件机制，来实现 Vite 的核心编译能力。</p>
<p>首先要考虑的就是入口 HTML 如何编译和加载的问题，这里我们可以通过一个服务中间件，配合插件机制来实现。具体而言，你可以新建<code>src/node/server/middlewares/indexHtml.ts</code>，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextHandleFunction</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"connect"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../index"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> { pathExists, readFile } <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">indexHtmlMiddware</span>(<span class="hljs-params">
  serverContext: ServerContext
</span>): <span class="hljs-title class_">NextHandleFunction</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span> === <span class="hljs-string">"/"</span>) {
      <span class="hljs-keyword">const</span> { root } = serverContext;
      <span class="hljs-comment">// 默认使用项目根目录下的 index.html</span>
      <span class="hljs-keyword">const</span> indexHtmlPath = path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">"index.html"</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">pathExists</span>(indexHtmlPath)) {
        <span class="hljs-keyword">const</span> rawHtml = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readFile</span>(indexHtmlPath, <span class="hljs-string">"utf8"</span>);
        <span class="hljs-keyword">let</span> html = rawHtml;
        <span class="hljs-comment">// 通过执行插件的 transformIndexHtml 方法来对 HTML 进行自定义的修改</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> plugin <span class="hljs-keyword">of</span> serverContext.<span class="hljs-property">plugins</span>) {
          <span class="hljs-keyword">if</span> (plugin.<span class="hljs-property">transformIndexHtml</span>) {
            html = <span class="hljs-keyword">await</span> plugin.<span class="hljs-title function_">transformIndexHtml</span>(html);
          }
        }

        res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">200</span>;
        res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"text/html"</span>);
        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(html);
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();
  };
}
</code></pre>
<p>然后在服务中应用这个中间件:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/server/index.ts</span>
<span class="hljs-comment">// 需要增加的引入语句</span>
<span class="hljs-keyword">import</span> { indexHtmlMiddware } <span class="hljs-keyword">from</span> <span class="hljs-string">"./middlewares/indexHtml"</span>;

<span class="hljs-comment">// 省略中间的代码</span>

<span class="hljs-comment">// 处理入口 HTML 资源</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">indexHtmlMiddware</span>(serverContext));

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">async</span> () => {
  <span class="hljs-comment">// 省略</span>
});
</code></pre>
<p>接下来通过<code>pnpm dev</code>启动项目，然后访问<code>http://localhost:3000</code>，从网络面板中你可以查看到 HTML 的内容已经成功返回:</p>
<p><img src="img\caf8a03a-ae61-11ed-afe8-342eb7027b95.jpg" alt="image.png"></p>
<p>不过当前的页面并没有任何内容，因为 HTML 中引入的 TSX 文件并没有被正确编译。接下来，我们就来处理 TSX 文件的编译工作。</p>
<h2>JS/TS/JSX/TSX 编译能力</h2>
<p>首先新增一个中间件<code>src/node/server/middlewares/transform.ts</code>，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextHandleFunction</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"connect"</span>;
<span class="hljs-keyword">import</span> {
  isJSRequest,
  cleanUrl,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"../../utils"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../index"</span>;
<span class="hljs-keyword">import</span> createDebug <span class="hljs-keyword">from</span> <span class="hljs-string">"debug"</span>;

<span class="hljs-keyword">const</span> debug = <span class="hljs-title function_">createDebug</span>(<span class="hljs-string">"dev"</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">transformRequest</span>(<span class="hljs-params">
  url: <span class="hljs-built_in">string</span>,
  serverContext: ServerContext
</span>) {
  <span class="hljs-keyword">const</span> { pluginContainer } = serverContext;
  url = <span class="hljs-title function_">cleanUrl</span>(url);
  <span class="hljs-comment">// 简单来说，就是依次调用插件容器的 resolveId、load、transform 方法</span>
  <span class="hljs-keyword">const</span> resolvedResult = <span class="hljs-keyword">await</span> pluginContainer.<span class="hljs-title function_">resolveId</span>(url);
  <span class="hljs-keyword">let</span> transformResult;
  <span class="hljs-keyword">if</span> (resolvedResult?.<span class="hljs-property">id</span>) {
    <span class="hljs-keyword">let</span> code = <span class="hljs-keyword">await</span> pluginContainer.<span class="hljs-title function_">load</span>(resolvedResult.<span class="hljs-property">id</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> code === <span class="hljs-string">"object"</span> &#x26;&#x26; code !== <span class="hljs-literal">null</span>) {
      code = code.<span class="hljs-property">code</span>;
    }
    <span class="hljs-keyword">if</span> (code) {
      transformResult = <span class="hljs-keyword">await</span> pluginContainer.<span class="hljs-title function_">transform</span>(
        code <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>,
        resolvedResult?.<span class="hljs-property">id</span>
      );
    }
  }
  <span class="hljs-keyword">return</span> transformResult;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">transformMiddleware</span>(<span class="hljs-params">
  serverContext: ServerContext
</span>): <span class="hljs-title class_">NextHandleFunction</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> !== <span class="hljs-string">"GET"</span> || !req.<span class="hljs-property">url</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();
    }
    <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span>;
    <span class="hljs-title function_">debug</span>(<span class="hljs-string">"transformMiddleware: %s"</span>, url);
    <span class="hljs-comment">// transform JS request</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isJSRequest</span>(url)) {
      <span class="hljs-comment">// 核心编译函数</span>
      <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">transformRequest</span>(url, serverContext);
      <span class="hljs-keyword">if</span> (!result) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();
      }
      <span class="hljs-keyword">if</span> (result &#x26;&#x26; <span class="hljs-keyword">typeof</span> result !== <span class="hljs-string">"string"</span>) {
        result = result.<span class="hljs-property">code</span>;
      }
      <span class="hljs-comment">// 编译完成，返回响应给浏览器</span>
      res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">200</span>;
      res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/javascript"</span>);
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(result);
    }

    <span class="hljs-title function_">next</span>();
  };
}
</code></pre>
<p>同时，我们也需要补充如下的工具函数和常量定义:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/utils.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">JS_TYPES_RE</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./constants.ts'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isJSRequest = (<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">boolean</span> =></span> {
  id = <span class="hljs-title function_">cleanUrl</span>(id);
  <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">JS_TYPES_RE</span>.<span class="hljs-title function_">test</span>(id)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">if</span> (!path.<span class="hljs-title function_">extname</span>(id) &#x26;&#x26; !id.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">"/"</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> cleanUrl = (<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =></span>
  url.<span class="hljs-title function_">replace</span>(<span class="hljs-variable constant_">HASH_RE</span>, <span class="hljs-string">""</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-variable constant_">QEURY_RE</span>, <span class="hljs-string">""</span>);
  
<span class="hljs-comment">// src/node/constants.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">JS_TYPES_RE</span> = <span class="hljs-regexp">/\.(?:j|t)sx?$|\.mjs$/</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">QEURY_RE</span> = <span class="hljs-regexp">/\?.*$/</span>s;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HASH_RE</span> = <span class="hljs-regexp">/#.*$/</span>s;
</code></pre>
<p>从如上的核心编译函数<code>transformRequest</code>可以看出，Vite 对于 JS/TS/JSX/TSX 文件的编译流程主要是依次调用插件容器的如下方法:</p>
<ul>
<li>resolveId</li>
<li>load</li>
<li>transform</li>
</ul>
<p>其中会经历众多插件的处理逻辑，那么，对于 TSX 文件的编译逻辑，也分散到了各个插件当中，具体来说主要包含以下的插件:</p>
<ul>
<li>路径解析插件</li>
<li>Esbuild 语法编译插件</li>
<li>import 分析插件</li>
</ul>
<p>接下来，我们就开始依次实现这些插件。</p>
<h3>1. 路径解析插件</h3>
<p>当浏览器解析到如下的标签时:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.tsx"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
</code></pre>
<p>会自动发送一个路径为<code>/src/main.tsx</code>的请求，但如果服务端不做任何处理，是无法定位到源文件的，随之会返回 404 状态码:</p>
<p><img src="img\cb0db38c-ae61-11ed-8a2a-342eb7027b95.jpg" alt="image.png"></p>
<p>因此，我们需要开发一个路径解析插件，对请求的路径进行处理，使之能转换真实文件系统中的路径。你可以新建文件<code>src/node/plugins/resolve.ts</code>，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">"resolve"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../plugin"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../server/index"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> { pathExists } <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">DEFAULT_EXTERSIONS</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants"</span>;
<span class="hljs-keyword">import</span> { cleanUrl, normalizePath } <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePlugin</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">serverContext</span>: <span class="hljs-title class_">ServerContext</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"m-vite:resolve"</span>,
    <span class="hljs-title function_">configureServer</span>(<span class="hljs-params">s</span>) {
      <span class="hljs-comment">// 保存服务端上下文</span>
      serverContext = s;
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">resolveId</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, importer?: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-comment">// 1. 绝对路径</span>
      <span class="hljs-keyword">if</span> (path.<span class="hljs-title function_">isAbsolute</span>(id)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">pathExists</span>(id)) {
          <span class="hljs-keyword">return</span> { id };
        }
        <span class="hljs-comment">// 加上 root 路径前缀，处理 /src/main.tsx 的情况</span>
        id = path.<span class="hljs-title function_">join</span>(serverContext.<span class="hljs-property">root</span>, id);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">pathExists</span>(id)) {
          <span class="hljs-keyword">return</span> { id };
        }
      }
      <span class="hljs-comment">// 2. 相对路径</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"."</span>)) {
        <span class="hljs-keyword">if</span> (!importer) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"`importer` should not be undefined"</span>);
        }
        <span class="hljs-keyword">const</span> hasExtension = path.<span class="hljs-title function_">extname</span>(id).<span class="hljs-property">length</span> > <span class="hljs-number">1</span>;
        <span class="hljs-keyword">let</span> <span class="hljs-attr">resolvedId</span>: <span class="hljs-built_in">string</span>;
        <span class="hljs-comment">// 2.1 包含文件名后缀</span>
        <span class="hljs-comment">// 如 ./App.tsx</span>
        <span class="hljs-keyword">if</span> (hasExtension) {
          resolvedId = <span class="hljs-title function_">normalizePath</span>(resolve.<span class="hljs-title function_">sync</span>(id, { <span class="hljs-attr">basedir</span>: path.<span class="hljs-title function_">dirname</span>(importer) }));
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">pathExists</span>(resolvedId)) {
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: resolvedId };
          }
        } 
        <span class="hljs-comment">// 2.2 不包含文件名后缀</span>
        <span class="hljs-comment">// 如 ./App</span>
        <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// ./App -> ./App.tsx</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> extname <span class="hljs-keyword">of</span> <span class="hljs-variable constant_">DEFAULT_EXTERSIONS</span>) {
            <span class="hljs-keyword">try</span> {
              <span class="hljs-keyword">const</span> withExtension = <span class="hljs-string">`<span class="hljs-subst">${id}</span><span class="hljs-subst">${extname}</span>`</span>;
              resolvedId = <span class="hljs-title function_">normalizePath</span>(resolve.<span class="hljs-title function_">sync</span>(withExtension, {
                <span class="hljs-attr">basedir</span>: path.<span class="hljs-title function_">dirname</span>(importer),
              }));
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">pathExists</span>(resolvedId)) {
                <span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: resolvedId };
              }
            } <span class="hljs-keyword">catch</span> (e) {
              <span class="hljs-keyword">continue</span>;
            }
          }
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    },
  };
}
</code></pre>
<p>这样对于 <code>/src/main.tsx</code>，在插件中会转换为文件系统中的真实路径，从而让模块在 load 钩子中能够正常加载(加载逻辑在 Esbuild 语法编译插件实现)。</p>
<p>接着我们来补充一下目前缺少的常量:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/constants.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_EXTERSIONS</span> = [<span class="hljs-string">".tsx"</span>, <span class="hljs-string">".ts"</span>, <span class="hljs-string">".jsx"</span>, <span class="hljs-string">"js"</span>];
</code></pre>
<h3>2. Esbuild 语法编译插件</h3>
<p>这个插件的作用比较好理解，就是将 JS/TS/JSX/TSX 编译成浏览器可以识别的 JS 语法，可以利用 Esbuild 的 Transform API 来实现。你可以新建<code>src/node/plugins/esbuild.ts</code>文件，内容如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { readFile } <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../plugin"</span>;
<span class="hljs-keyword">import</span> { isJSRequest } <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils"</span>;
<span class="hljs-keyword">import</span> esbuild <span class="hljs-keyword">from</span> <span class="hljs-string">"esbuild"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">esbuildTransformPlugin</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"m-vite:esbuild-transform"</span>,
    <span class="hljs-comment">// 加载模块</span>
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">id</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isJSRequest</span>(id)) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">const</span> code = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readFile</span>(id, <span class="hljs-string">"utf-8"</span>);
          <span class="hljs-keyword">return</span> code;
        } <span class="hljs-keyword">catch</span> (e) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      }
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isJSRequest</span>(id)) {
        <span class="hljs-keyword">const</span> extname = path.<span class="hljs-title function_">extname</span>(id).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">code</span>: transformedCode, map } = <span class="hljs-keyword">await</span> esbuild.<span class="hljs-title function_">transform</span>(code, {
          <span class="hljs-attr">target</span>: <span class="hljs-string">"esnext"</span>,
          <span class="hljs-attr">format</span>: <span class="hljs-string">"esm"</span>,
          <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">loader</span>: extname <span class="hljs-keyword">as</span> <span class="hljs-string">"js"</span> | <span class="hljs-string">"ts"</span> | <span class="hljs-string">"jsx"</span> | <span class="hljs-string">"tsx"</span>,
        });
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">code</span>: transformedCode,
          map,
        };
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    },
  };
}
</code></pre>
<h3>3. import 分析插件</h3>
<p>在将 TSX 转换为浏览器可以识别的语法之后，是不是就可以直接返回给浏览器执行了呢？</p>
<p>显然不是，我们还考虑如下的一些问题:</p>
<ul>
<li>对于第三方依赖路径(bare import)，需要重写为预构建产物路径；</li>
<li>对于绝对路径和相对路径，需要借助之前的路径解析插件进行解析。</li>
</ul>
<p>好，接下来，我们就在 import 分析插件中一一解决这些问题:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 新建 src/node/plugins/importAnalysis.ts</span>
<span class="hljs-keyword">import</span> { init, parse } <span class="hljs-keyword">from</span> <span class="hljs-string">"es-module-lexer"</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-variable constant_">BARE_IMPORT_RE</span>,
  <span class="hljs-variable constant_">DEFAULT_EXTERSIONS</span>,
  <span class="hljs-variable constant_">PRE_BUNDLE_DIR</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants"</span>;
<span class="hljs-keyword">import</span> {
  cleanUrl,
  isJSRequest,
  normalizePath
} <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils"</span>;
<span class="hljs-comment">// magic-string 用来作字符串编辑</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MagicString</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"magic-string"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../plugin"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../server/index"</span>;
<span class="hljs-keyword">import</span> { pathExists } <span class="hljs-keyword">from</span> <span class="hljs-string">"fs-extra"</span>;
<span class="hljs-keyword">import</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">"resolve"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">importAnalysisPlugin</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">serverContext</span>: <span class="hljs-title class_">ServerContext</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"m-vite:import-analysis"</span>,
    <span class="hljs-title function_">configureServer</span>(<span class="hljs-params">s</span>) {
      <span class="hljs-comment">// 保存服务端上下文</span>
      serverContext = s;
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span>, id: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-comment">// 只处理 JS 相关的请求</span>
      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isJSRequest</span>(id)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">await</span> init;
      <span class="hljs-comment">// 解析 import 语句</span>
      <span class="hljs-keyword">const</span> [imports] = <span class="hljs-title function_">parse</span>(code);
      <span class="hljs-keyword">const</span> ms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicString</span>(code);
      <span class="hljs-comment">// 对每一个 import 语句依次进行分析</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> importInfo <span class="hljs-keyword">of</span> imports) {
        <span class="hljs-comment">// 举例说明: const str = `import React from 'react'`</span>
        <span class="hljs-comment">// str.slice(s, e) => 'react'</span>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">s</span>: modStart, <span class="hljs-attr">e</span>: modEnd, <span class="hljs-attr">n</span>: modSource } = importInfo;
        <span class="hljs-keyword">if</span> (!modSource) <span class="hljs-keyword">continue</span>;
        <span class="hljs-comment">// 第三方库: 路径重写到预构建产物的路径</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">BARE_IMPORT_RE</span>.<span class="hljs-title function_">test</span>(modSource)) {
           <span class="hljs-keyword">const</span> bundlePath = <span class="hljs-title function_">normalizePath</span>(
            path.<span class="hljs-title function_">join</span>(<span class="hljs-string">'/'</span>, <span class="hljs-variable constant_">PRE_BUNDLE_DIR</span>, <span class="hljs-string">`<span class="hljs-subst">${modSource}</span>.js`</span>)
          );
          ms.<span class="hljs-title function_">overwrite</span>(modStart, modEnd, bundlePath);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (modSource.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"."</span>) || modSource.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"/"</span>)) {
          <span class="hljs-comment">// 直接调用插件上下文的 resolve 方法，会自动经过路径解析插件的处理</span>
          <span class="hljs-keyword">const</span> resolved = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resolve</span>(modSource, id);
          <span class="hljs-keyword">if</span> (resolved) {
            ms.<span class="hljs-title function_">overwrite</span>(modStart, modEnd, resolved.<span class="hljs-property">id</span>);
          }
        }
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: ms.<span class="hljs-title function_">toString</span>(),
        <span class="hljs-comment">// 生成 SourceMap</span>
        <span class="hljs-attr">map</span>: ms.<span class="hljs-title function_">generateMap</span>(),
      };
    },
  };
}
</code></pre>
<p>现在，我们便完成了 JS 代码的 import 分析工作。接下来，我们把上面实现的三个插件进行注册:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/node/plugin/index.ts</span>
<span class="hljs-keyword">import</span> { esbuildTransformPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">"./esbuild"</span>;
<span class="hljs-keyword">import</span> { importAnalysisPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">"./importAnalysis"</span>;
<span class="hljs-keyword">import</span> { resolvePlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">"./resolve"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../plugin"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePlugins</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Plugin</span>[] {
  <span class="hljs-keyword">return</span> [<span class="hljs-title function_">resolvePlugin</span>(), <span class="hljs-title function_">esbuildTransformPlugin</span>(), <span class="hljs-title function_">importAnalysisPlugin</span>()];
}

</code></pre>
<p>当然，我们需要注册 transformMiddleware 中间件，在<code>src/node/server/index.ts</code>中增加代码如下:</p>
<pre><code class="hljs language-ts">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">transformMiddleware</span>(serverContext));
</code></pre>
<p>然后在<code>playground</code>项目下执行<code>pnpm dev</code>，在浏览器里面访问<code>http://localhost:3000</code>，你可以在网络面板中发现 <code>main.tsx</code> 的内容以及被编译为下面这样:</p>
<p><img src="img\cb29d381-ae61-11ed-8057-342eb7027b95.jpg" alt="image.png"></p>
<p>同时，页面内容也能被渲染出来了:</p>
<p><img src="img\cb4041b7-ae61-11ed-a9df-342eb7027b95.jpg" alt="image.png"></p>
<p>OK，目前为止我们就基本上完成 JS/TS/JSX/TSX 文件的编译。</p>
<h2>小结</h2>
<p>本小节的内容就到这里，相信你如果能一直跟着做到这里，也已经收获满满了。我们最后来回顾和小结一下，这一节我们主要来手写 Vite 的 no-bundle 服务，完成了<strong>开发环境搭建</strong>、<strong>预构建功能的开发</strong>、<strong>插件机制的搭建</strong>、<strong>入口 HTML 加载</strong>和 <strong>JS/TS/JSX/TSX 的编译功能</strong>。</p>
<p>在下一小节，我们将继续完善当前的 no-bundle 服务器，完成 CSS 编译、静态资源加载和 HMR 系统的实现，让我们下一节再见👋🏻</p>
</div>
</body>
</html>