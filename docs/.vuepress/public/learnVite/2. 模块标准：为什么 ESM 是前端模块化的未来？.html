<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <title>Title</title>-->
    <style>
        body {
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial !important;
}

.markdown-body {
    word-break: break-word;
    line-height: 1.75;
    font-weight: 400;
    font-size: 16px;
    overflow-x: hidden;
    color: #333
}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    line-height: 1.5;
    margin-top: 35px;
    margin-bottom: 10px;
    padding-bottom: 5px
}

.markdown-body h1 {
    font-size: 24px;
    margin-bottom: 5px
}

.markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    font-size: 20px
}

.markdown-body h2 {
    padding-bottom: 12px;
    border-bottom: 1px solid #ececec
}

.markdown-body h3 {
    font-size: 18px;
    padding-bottom: 0
}

.markdown-body h6 {
    margin-top: 5px
}

.markdown-body p {
    line-height: inherit;
    margin-top: 22px;
    margin-bottom: 22px
}

.markdown-body img {
    max-width: 100%
}

.markdown-body hr {
    border: none;
    border-top: 1px solid #ddd;
    margin-top: 32px;
    margin-bottom: 32px
}

.markdown-body code {
    word-break: break-word;
    border-radius: 2px;
    overflow-x: auto;
    background-color: #fff5f5;
    color: #ff502c;
    font-size: .87em;
    padding: .065em .4em
}

.markdown-body code, .markdown-body pre {
    font-family: Menlo, Monaco, Consolas, Courier New, monospace
}

.markdown-body pre {
    overflow: auto;
    position: relative;
    line-height: 1.75
}

.markdown-body pre > code {
    font-size: 12px;
    padding: 15px 12px;
    margin: 0;
    word-break: normal;
    display: block;
    overflow-x: auto;
    color: #333;
    background: #f8f8f8
}

.markdown-body a {
    text-decoration: none;
    color: #0269c8;
    border-bottom: 1px solid #d1e9ff
}

.markdown-body a:active, .markdown-body a:hover {
    color: #275b8c
}

.markdown-body table {
    display: inline-block !important;
    font-size: 12px;
    width: auto;
    max-width: 100%;
    overflow: auto;
    border: 1px solid #f6f6f6
}

.markdown-body thead {
    background: #f6f6f6;
    color: #000;
    text-align: left
}

.markdown-body tr:nth-child(2n) {
    background-color: #fcfcfc
}

.markdown-body td, .markdown-body th {
    padding: 12px 7px;
    line-height: 24px
}

.markdown-body td {
    min-width: 120px
}

.markdown-body blockquote {
    color: #666;
    padding: 1px 23px;
    margin: 22px 0;
    border-left: 4px solid #cbcbcb;
    background-color: #f8f8f8
}

.markdown-body blockquote:after {
    display: block;
    content: ""
}

.markdown-body blockquote > p {
    margin: 10px 0
}

.markdown-body ol, .markdown-body ul {
    padding-left: 28px
}

.markdown-body ol li, .markdown-body ul li {
    margin-bottom: 0;
    list-style: inherit
}

.markdown-body ol li .task-list-item, .markdown-body ul li .task-list-item {
    list-style: none
}

.markdown-body ol li .task-list-item ol, .markdown-body ol li .task-list-item ul, .markdown-body ul li .task-list-item ol, .markdown-body ul li .task-list-item ul {
    margin-top: 0
}

.markdown-body ol ol, .markdown-body ol ul, .markdown-body ul ol, .markdown-body ul ul {
    margin-top: 3px
}

.markdown-body ol li {
    padding-left: 6px
}

.markdown-body .contains-task-list {
    padding-left: 0
}

.markdown-body .task-list-item {
    list-style: none
}

@media (max-width: 720px) {
    .markdown-body h1 {
        font-size: 24px
    }

    .markdown-body h2 {
        font-size: 20px
    }

    .markdown-body h3 {
        font-size: 18px
    }
}
    </style>
</head>
<body>
<div class="markdown-body">
    <p>2002 年 AJAX 诞生至今，前端从刀耕火种的年代，经历了一系列的发展，各种标准和工具百花齐放。下图中我们可以看到，自 2009 年 Node.js 诞生，前端先后出现了 <code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>、<code>UMD</code>和<code>ES Module</code> 等模块规范，底层规范的发展催生出了一系列工具链的创新，比如 AMD 规范提出时社区诞生的模块加载工具<code>requireJS</code>，基于 CommonJS 规范的模块打包工具<code>browserify</code>，还有能让用户提前用上 <code>ES Module</code> 语法的 JS 编译器<code>Babel</code>、兼容各种模块规范的重量级打包工具<code>Webpack</code>以及基于浏览器原生 ES Module 支持而实现的 <strong>no-bundle</strong> 构建工具 <code>Vite</code> 等等。</p>
<p><img src="img\b1dc6a91-ae61-11ed-9c05-342eb7027b95.jpg" alt=""></p>
<p>总体而言，业界经历了一系列<strong>由规范、标准引领工程化改革</strong>的过程。构建工具作为前端工程化的核心要素，与底层的前端模块化规范和标准息息相关。接下来的时间，我就带你梳理一下前端模块化是如何演进的。这样你能更清楚地了解到各种模块化标准诞生的背景和意义，也能更好地理解 ES Module 为什么能够成为现今最主流的前端模块化标准。</p>
<h3>无模块化标准阶段</h3>
<p>早在模块化标准还没有诞生的时候，前端界已经产生了一些模块化的开发手段，如<code>文件划分</code>、<code>命名空间</code>和 <code>IIFE 私有作用域</code>。下面，我来简单介绍一下它们的实现以及背后存在的问题。</p>
<h4>1. 文件划分</h4>
<p>文件划分方式是最原始的模块化实现，简单来说就是将应用的状态和逻辑分散到不同的文件中，然后通过 HTML 中的 script 来一一引入。下面是一个通过<code>文件划分</code>实现模块化的具体例子:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>
<span class="hljs-keyword">let</span> data = <span class="hljs-string">"data"</span>;
</code></pre>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-b.js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"execute method"</span>);
}
</code></pre>
<pre><code class="hljs language-html">// index.html
<span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Document<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-a.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-b.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
      <span class="hljs-built_in">console</span>.log(data);
      method();
    </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>
</code></pre>
<p>从中可以看到<code>module-a</code>和<code>module-b</code>为两个不同的模块，通过两个 script 标签分别引入到 HTML 中，这么做看似是分散了不同模块的状态和运行逻辑，但实际上也隐藏着一些风险因素:</p>
<ol>
<li>
<p>模块变量相当于在全局声明和定义，会有变量名冲突的问题。比如 <code>module-b</code> 可能也存在<code>data</code>变量，这就会与 <code>module-a</code> 中的变量冲突。</p>
</li>
<li>
<p>由于变量都在全局定义，我们很难知道某个变量到底属于哪些模块，因此也给调试带来了困难。</p>
</li>
<li>
<p>无法清晰地管理模块之间的依赖关系和加载顺序。假如<code>module-a</code>依赖<code>module-b</code>，那么上述 HTML 的 script 执行顺序需要手动调整，不然可能会产生运行时错误。</p>
</li>
</ol>
<h4>2. 命名空间</h4>
<p><code>命名空间</code>是模块化的另一种实现手段，它可以解决上述文件划分方式中<code>全局变量定义</code>所带来的一系列问题。下面是一个简单的例子:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>
<span class="hljs-built_in">window</span>.moduleA = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">"moduleA"</span>,
  <span class="hljs-attr">method</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"execute A's method"</span>);
  },
};
</code></pre>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-b.js</span>
<span class="hljs-built_in">window</span>.moduleB = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">"moduleB"</span>,
  <span class="hljs-attr">method</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"execute B's method"</span>);
  },
};
</code></pre>
<pre><code class="hljs language-html"><span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Document<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-a.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-b.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
      <span class="hljs-comment">// 此时 window 上已经绑定了 moduleA 和 moduleB</span>
      <span class="hljs-built_in">console</span>.log(moduleA.data);
      moduleB.method();
    </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>
</code></pre>
<p>这样一来，每个变量都有自己专属的命名空间，我们可以清楚地知道某个变量到底属于哪个<code>模块</code>，同时也避免全局变量命名的问题。</p>
<h4>3. IIFE(立即执行函数)</h4>
<p>不过，相比于<code>命名空间</code>的模块化手段，<code>IIFE</code>实现的模块化安全性要更高，对于模块作用域的区分更加彻底。你可以参考如下<code>IIFE 实现模块化</code>的例子:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">"moduleA"</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(data + <span class="hljs-string">"execute"</span>);
  }

  <span class="hljs-built_in">window</span>.moduleA = {
    <span class="hljs-attr">method</span>: method,
  };
})();
</code></pre>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-b.js</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">"moduleB"</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(data + <span class="hljs-string">"execute"</span>);
  }

  <span class="hljs-built_in">window</span>.moduleB = {
    <span class="hljs-attr">method</span>: method,
  };
})();
</code></pre>
<pre><code class="hljs language-html">// index.html
<span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Document<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-a.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./module-b.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
      <span class="hljs-comment">// 此时 window 上已经绑定了 moduleA 和 moduleB</span>
      <span class="hljs-built_in">console</span>.log(moduleA.data);
      moduleB.method();
    </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>
</code></pre>
<p>我们知道，每个<code>IIFE</code> 即<code>立即执行函数</code>都会创建一个私有的作用域，在私有作用域中的变量外界是无法访问的，只有模块内部的方法才能访问。拿上述的<code>module-a</code>来说:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">"moduleA"</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">method</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(data + <span class="hljs-string">"execute"</span>);
  }

  <span class="hljs-built_in">window</span>.moduleA = {
    <span class="hljs-attr">method</span>: method,
  };
})();
</code></pre>
<p>对于其中的 <code>data</code>变量，我们只能在模块内部的 <code>method</code> 函数中通过闭包访问，而在其它模块中无法直接访问。这就是模块<code>私有成员</code>功能，避免模块私有成员被其他模块非法篡改，相比于<code>命名空间</code>的实现方式更加安全。</p>
<p>但实际上，无论是<code>命名空间</code>还是<code>IIFE</code>，都是为了解决全局变量所带来的命名冲突及作用域不明确的问题，也就是在<code>文件划分方式</code>中所总结的<code>问题 1</code> 和<code>问题 2</code>，而并没有真正解决另外一个问题——<strong>模块加载</strong>。如果模块间存在依赖关系，那么 script 标签的加载顺序就需要受到严格的控制，一旦顺序不对，则很有可能产生运行时 Bug。</p>
<p>而随着前端工程的日益庞大，各个模块之间相互依赖已经是非常常见的事情，模块加载的需求已经成为了业界刚需，而以上的几种非标准模块化手段不能满足这个需求，因此我们需要指定一个行业标准去统一前端代码的模块化。</p>
<p>不过前端的模块化规范统一也经历了漫长的发展阶段，即便是到现在也没有实现完全的统一。接下来，我们就来熟悉一下业界主流的三大模块规范: <code>CommonJS</code>、<code>AMD</code> 和 <code>ES Module</code>。</p>
<h3>CommonJS 规范</h3>
<p>CommonJS 是业界最早正式提出的 JavaScript 模块规范，主要用于服务端，随着 Node.js 越来越普及，这个规范也被业界广泛应用。对于模块规范而言，一般会包含 2 方面内容:</p>
<ul>
<li>
<p>统一的模块化代码规范</p>
</li>
<li>
<p>实现自动加载模块的加载器(也称<code>loader</code>)</p>
</li>
</ul>
<p>对于 CommonJS 模块规范本身，相信有 Node.js 使用经验的同学都不陌生了，为了方便你理解，我举一个使用 CommonJS 的简单例子:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>
<span class="hljs-keyword">var</span> data = <span class="hljs-string">"hello world"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> data;
}
<span class="hljs-built_in">module</span>.exports = {
  getData,
};

<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">const</span> { getData } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./module-a.js"</span>);
<span class="hljs-built_in">console</span>.log(getData());
</code></pre>
<p>代码中使用 <code>require</code> 来导入一个模块，用<code>module.exports</code>来导出一个模块。实际上 Node.js 内部会有相应的 loader 转译模块代码，最后模块代码会被处理成下面这样:</p>
<pre><code class="hljs language-ts">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span>, <span class="hljs-built_in">module</span>, __filename, __dirname</span>) </span>{
  <span class="hljs-comment">// 执行模块代码</span>
  <span class="hljs-comment">// 返回 exports 对象</span>
});
</code></pre>
<p>对 CommonJS 而言，一方面它定义了一套完整的模块化代码规范，另一方面 Node.js 为之实现了自动加载模块的<code>loader</code>，看上去是一个很不错的模块规范，但也存在一些问题:</p>
<ol>
<li>模块加载器由 Node.js 提供，依赖了 Node.js 本身的功能实现，比如文件系统，如果 CommonJS 模块直接放到浏览器中是无法执行的。当然, 业界也产生了 <a href="https://github.com/browserify/browserify" target="_blank" rel="nofollow noopener noreferrer">browserify</a> 这种打包工具来支持打包 CommonJS 模块，从而顺利在浏览器中执行，相当于社区实现了一个第三方的 loader。</li>
<li>CommonJS 本身约定以同步的方式进行模块加载，这种加载机制放在服务端是没问题的，一来模块都在本地，不需要进行网络 IO，二来只有服务启动时才会加载模块，而服务通常启动后会一直运行，所以对服务的性能并没有太大的影响。但如果这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。也就是说，<strong>模块请求会造成浏览器 JS 解析过程的阻塞</strong>，导致页面加载速度缓慢。</li>
</ol>
<p>总之，CommonJS 是一个不太适合在浏览器中运行的模块规范。因此，业界也设计出了全新的规范来作为浏览器端的模块标准，最知名的要数 <code>AMD</code> 了。</p>
<h3>AMD 规范</h3>
<p><code>AMD</code>全称为<code>Asynchronous Module Definition</code>，即异步模块定义规范。模块根据这个规范，在浏览器环境中会被异步加载，而不会像 CommonJS 规范进行同步加载，也就不会产生同步请求导致的浏览器解析过程阻塞的问题了。我们先来看看这个模块规范是如何来使用的:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// main.js</span>
define([<span class="hljs-string">"./print"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">printModule</span>) </span>{
  printModule.print(<span class="hljs-string">"main"</span>);
});

<span class="hljs-comment">// print.js</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">print</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"print "</span> + msg);
    },
  };
});
</code></pre>
<p>在 AMD 规范当中，我们可以通过 define 去定义或加载一个模块，比如上面的 <code>main</code> 模块和<code>print</code>模块，如果模块需要导出一些成员需要通过在定义模块的函数中 return 出去(参考 <code>print</code> 模块)，如果当前模块依赖了一些其它的模块则可以通过 define 的第一个参数来声明依赖(参考<code>main</code>模块)，这样模块的代码执行之前浏览器会先<strong>加载依赖模块</strong>。</p>
<p>当然，你也可以使用 require 关键字来加载一个模块，如:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// module-a.js</span>
<span class="hljs-built_in">require</span>([<span class="hljs-string">"./print.js"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">printModule</span>) </span>{
  printModule.print(<span class="hljs-string">"module-a"</span>);
});
</code></pre>
<p>不过 require 与 define 的区别在于前者只能加载模块，而<code>不能定义一个模块</code>。</p>
<p>由于没有得到浏览器的原生支持，AMD 规范需要由第三方的 loader 来实现，最经典的就是 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="nofollow noopener noreferrer">requireJS</a> 库了，它完整实现了 AMD 规范，至今仍然有不少项目在使用。</p>
<p>不过 AMD 规范使用起来稍显复杂，代码阅读和书写都比较困难。因此，这个规范并不能成为前端模块化的终极解决方案，仅仅是社区中提出的一个妥协性的方案，关于新的模块化规范的探索，业界从仍未停止脚步。</p>
<p>同期出现的规范当中也有 CMD 规范，这个规范是由淘宝出品的<code>SeaJS</code>实现的，解决的问题和 AMD 一样。不过随着社区的不断发展，SeaJS 已经被<code>requireJS</code>兼容了。</p>
<blockquote>
<p>当然，你可能也听说过 <code>UMD</code> (Universal Module Definition)规范，其实它并不算一个新的规范，只是兼容 AMD 和 CommonJS 的一个模块化方案，可以同时运行在浏览器和 Node.js 环境。顺便提一句，后面将要介绍的 ES Module 也具备这种跨平台的能力。</p>
</blockquote>
<h3>ES6 Module</h3>
<p><code>ES6 Module</code> 也被称作 <code>ES Module</code>(或 <code>ESM</code>)， 是由 ECMAScript 官方提出的模块化规范，作为一个官方提出的规范，<code>ES Module</code> 已经得到了现代浏览器的内置支持。在现代浏览器中，如果在 HTML 中加入含有<code>type="module"</code>属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，这也是 Vite 在开发阶段实现 no-bundle 的原因，由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码，具体的模块加载流程我们会在下一节进行详细的解释。</p>
<p>大家可能会担心 ES Module 的兼容性问题，其实 ES Module 的浏览器兼容性如今已经相当好了，覆盖了 90% 以上的浏览器份额，在 <a href="https://caniuse.com/" target="_blank" rel="nofollow noopener noreferrer">CanIUse</a> 上的详情数据如下图所示:</p>
<p><img src="img\b1ffd7de-ae61-11ed-bf49-342eb7027b95.jpg" alt=""></p>
<p>不仅如此，一直以 CommonJS 作为模块标准的 Node.js 也紧跟 ES Module 的发展步伐，从 <code>12.20</code> 版本开始<a href="https://nodejs.org/api/esm.html#modules-ecmascript-modules" target="_blank" rel="nofollow noopener noreferrer">正式支持</a>原生 ES Module。也就是说，如今 ES Module 能够同时在浏览器与 Node.js 环境中执行，拥有天然的跨平台能力。</p>
<p>下面是一个使用 ES Module 的简单例子:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { methodA } <span class="hljs-keyword">from</span> <span class="hljs-string">"./module-a.js"</span>;
methodA();

<span class="hljs-comment">//module-a.js</span>
<span class="hljs-keyword">const</span> methodA = <span class="hljs-function">() =></span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a"</span>);
};

<span class="hljs-keyword">export</span> { methodA };
</code></pre>
<pre><code class="hljs language-html"><span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/src/favicon.svg"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Vite App<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./main.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>
</code></pre>
<p>如果在 Node.js 环境中，你可以在<code>package.json</code>中声明<code>type: "module"</code>属性:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// package.json</span>
{
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"module"</span>
}
</code></pre>
<p>然后 Node.js 便会默认以 ES Module 规范去解析模块:</p>
<pre><code class="hljs language-ts">node main.js
<span class="hljs-comment">// 打印 a</span>
</code></pre>
<p>顺便说一句，在 Node.js 中，即使是在 CommonJS 模块里面，也可以通过 <code>import</code> 方法顺利加载 ES 模块，如下所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 加载一个 ES 模块</span>
  <span class="hljs-comment">// 文件名后缀需要是 mjs</span>
  <span class="hljs-keyword">const</span> { a } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./module-a.mjs"</span>);
  <span class="hljs-built_in">console</span>.log(a);
}

func();

<span class="hljs-built_in">module</span>.exports = {
  func,
};
</code></pre>
<p>ES Module 作为 ECMAScript 官方提出的规范，经过五年多的发展，不仅得到了众多浏览器的原生支持，也在 Node.js 中得到了原生支持，是一个能够跨平台的模块规范。同时，它也是社区各种生态库的发展趋势，尤其是被如今大火的构建工具 Vite 所深度应用。可以说，ES Module 前景一片光明，成为前端大一统的模块标准指日可待。</p>
<p>当然，这一讲我们只简单介绍了 ESM。至于高级特性，我们将在「高级应用篇」专门介绍。你可以先利用我这里给到的官方资料提前预习： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="nofollow noopener noreferrer">MDN 官方解释</a>、<a href="https://262.ecma-international.org/6.0/#sec-modules" target="_blank" rel="nofollow noopener noreferrer">ECMAScript 内部提案细节</a>。</p>
<h2>小结</h2>
<p>这一节，我们要重点掌握<strong>前端模块化的诞生意义</strong>、<strong>主流的模块化规范</strong>和 <strong>ESM 规范的优势</strong>。</p>
<p>由于前端构建工具的改革与底层模块化规范的发展息息相关，从一开始我就带你从头梳理了前端模块化的演进史，从无模块化标准的时代开始谈起，跟你介绍了<code>文件划分</code>的模块化方案，并分析了这个方案潜在的几个问题。随后又介绍了<code>命名空间</code>和<code>IIFE</code>两种方案，但这两种方式并没有解决模块自动加载的问题。由此展开对前端模块化规范的介绍，我主要给你分析了三个主流的模块化标准: <code>CommonJS</code>、<code>AMD</code> 以及 <code>ES Module</code>，针对每个规范从<code>模块化代码标准</code>、<code>模块自动加载方案</code>这两个维度给你进行了详细的拆解，最后得出 ES Module 即将成为主流前端模块化方案的结论。</p>
<p>本小节的内容就到这里了，希望能对你有所启发，也欢迎你把自己的学习心得打到评论区，我们下一节再见~</p>
</div>
</body>
</html>