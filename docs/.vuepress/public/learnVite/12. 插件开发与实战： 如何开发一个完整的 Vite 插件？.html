<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <title>Title</title>-->
    <style>
        body {
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial !important;
}

.markdown-body {
    word-break: break-word;
    line-height: 1.75;
    font-weight: 400;
    font-size: 16px;
    overflow-x: hidden;
    color: #333
}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    line-height: 1.5;
    margin-top: 35px;
    margin-bottom: 10px;
    padding-bottom: 5px
}

.markdown-body h1 {
    font-size: 24px;
    margin-bottom: 5px
}

.markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    font-size: 20px
}

.markdown-body h2 {
    padding-bottom: 12px;
    border-bottom: 1px solid #ececec
}

.markdown-body h3 {
    font-size: 18px;
    padding-bottom: 0
}

.markdown-body h6 {
    margin-top: 5px
}

.markdown-body p {
    line-height: inherit;
    margin-top: 22px;
    margin-bottom: 22px
}

.markdown-body img {
    max-width: 100%
}

.markdown-body hr {
    border: none;
    border-top: 1px solid #ddd;
    margin-top: 32px;
    margin-bottom: 32px
}

.markdown-body code {
    word-break: break-word;
    border-radius: 2px;
    overflow-x: auto;
    background-color: #fff5f5;
    color: #ff502c;
    font-size: .87em;
    padding: .065em .4em
}

.markdown-body code, .markdown-body pre {
    font-family: Menlo, Monaco, Consolas, Courier New, monospace
}

.markdown-body pre {
    overflow: auto;
    position: relative;
    line-height: 1.75
}

.markdown-body pre > code {
    font-size: 12px;
    padding: 15px 12px;
    margin: 0;
    word-break: normal;
    display: block;
    overflow-x: auto;
    color: #333;
    background: #f8f8f8
}

.markdown-body a {
    text-decoration: none;
    color: #0269c8;
    border-bottom: 1px solid #d1e9ff
}

.markdown-body a:active, .markdown-body a:hover {
    color: #275b8c
}

.markdown-body table {
    display: inline-block !important;
    font-size: 12px;
    width: auto;
    max-width: 100%;
    overflow: auto;
    border: 1px solid #f6f6f6
}

.markdown-body thead {
    background: #f6f6f6;
    color: #000;
    text-align: left
}

.markdown-body tr:nth-child(2n) {
    background-color: #fcfcfc
}

.markdown-body td, .markdown-body th {
    padding: 12px 7px;
    line-height: 24px
}

.markdown-body td {
    min-width: 120px
}

.markdown-body blockquote {
    color: #666;
    padding: 1px 23px;
    margin: 22px 0;
    border-left: 4px solid #cbcbcb;
    background-color: #f8f8f8
}

.markdown-body blockquote:after {
    display: block;
    content: ""
}

.markdown-body blockquote > p {
    margin: 10px 0
}

.markdown-body ol, .markdown-body ul {
    padding-left: 28px
}

.markdown-body ol li, .markdown-body ul li {
    margin-bottom: 0;
    list-style: inherit
}

.markdown-body ol li .task-list-item, .markdown-body ul li .task-list-item {
    list-style: none
}

.markdown-body ol li .task-list-item ol, .markdown-body ol li .task-list-item ul, .markdown-body ul li .task-list-item ol, .markdown-body ul li .task-list-item ul {
    margin-top: 0
}

.markdown-body ol ol, .markdown-body ol ul, .markdown-body ul ol, .markdown-body ul ul {
    margin-top: 3px
}

.markdown-body ol li {
    padding-left: 6px
}

.markdown-body .contains-task-list {
    padding-left: 0
}

.markdown-body .task-list-item {
    list-style: none
}

@media (max-width: 720px) {
    .markdown-body h1 {
        font-size: 24px
    }

    .markdown-body h2 {
        font-size: 20px
    }

    .markdown-body h3 {
        font-size: 18px
    }
}
    </style>
</head>
<body>
<div class="markdown-body">
    <p>前面的几个小节，我们从 Vite 双引擎的角度了解了 Vite 的整体架构，也系统学了双引擎本身的基础知识。从本小节开始，我们正式学习 <strong>Vite 高级应用</strong>。</p>
<p>这一模块中，我们将深入应用 Vite 的各项高级能力，遇到更多有挑战的开发场景。你不仅能学会一系列有难度的<strong>解决方案</strong>，直接运用到实际项目中，还能系统提高自己的<strong>知识深度</strong>，体会复杂项目场景中构建工具如何提供高度自定义的能力，以及如何对项目进行性能优化。</p>
<p>说到自定义的能力，你肯定很容易想到<code>插件机制</code>，利用一个个插件来扩展构建工具自身的能力。没错，这一节中我们将系统学习 Vite 的插件机制，带你掌握 Vite 插件开发的基本知识以及实战开发技巧。</p>
<p>虽然 Vite 的插件机制是基于 Rollup 来设计的，并且上一小节我们也已经对 Rollup 的插件机制进行了详细的解读，但实际上 Vite 的插件机制也包含了自己独有的一部分，与 Rollup 的各个插件 Hook 并非完全兼容，因此本节我们将重点关注 Vite 独有的部分以及和 Rollup 所区别的部分，而对于 Vite 和 Rollup 中相同的 Hook (如<code>resolveId</code>、<code>load</code>、<code>transform</code>)只是稍微提及，就不再展开赘述了。</p>
<p>让我们先从一个简单的例子入手吧！</p>
<h2>一个简单的插件示例</h2>
<p>Vite 插件与 Rollup 插件结构类似，为一个<code>name</code>和各种插件 Hook 的对象:</p>
<pre><code class="hljs language-ts">{
  <span class="hljs-comment">// 插件名称</span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-xxx'</span>,
  <span class="hljs-title function_">load</span>(<span class="hljs-params">code</span>) {
    <span class="hljs-comment">// 钩子逻辑</span>
  },
}
</code></pre>
<blockquote>
<p>如果插件是一个 npm 包，在<code>package.json</code>中的包命名也推荐以<code>vite-plugin</code>开头</p>
</blockquote>
<p>一般情况下因为要考虑到外部传参，我们不会直接写一个对象，而是实现一个返回插件对象的<code>工厂函数</code>，如下代码所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// myPlugin.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myVitePlugin</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options)
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-xxx'</span>,
    <span class="hljs-title function_">load</span>(<span class="hljs-params">id</span>) {
      <span class="hljs-comment">// 在钩子逻辑中可以通过闭包访问外部的 options 传参</span>
    }
  }
}

<span class="hljs-comment">// 使用方式</span>
<span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { myVitePlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">'./myVitePlugin'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">myVitePlugin</span>({ <span class="hljs-comment">/* 给插件传参 */</span> })]
}
</code></pre>
<h2>插件 Hook 介绍</h2>
<h3>1. 通用 Hook</h3>
<p>在<a href="https://juejin.cn/book/7050063811973218341/section/7060398408430780431" target="_blank" rel="nofollow noopener noreferrer">双引擎架构</a>这一节中介绍过，Vite <strong>开发阶段</strong>会模拟 Rollup 的行为:</p>
<p><img src="img\bb02446c-ae61-11ed-8853-342eb7027b95.jpg" alt="image.png"></p>
<p>其中 Vite 会调用一系列与 Rollup 兼容的钩子，这个钩子主要分为三个阶段:</p>
<ul>
<li><strong>服务器启动阶段</strong>: <code>options</code>和<code>buildStart</code>钩子会在服务启动时被调用。</li>
<li><strong>请求响应阶段</strong>: 当浏览器发起请求时，Vite 内部依次调用<code>resolveId</code>、<code>load</code>和<code>transform</code>钩子。</li>
<li><strong>服务器关闭阶段</strong>: Vite 会依次执行<code>buildEnd</code>和<code>closeBundle</code>钩子。</li>
</ul>
<p>除了以上钩子，其他 Rollup 插件钩子(如<code>moduleParsed</code>、<code>renderChunk</code>)均不会在 Vite <strong>开发阶段</strong>调用。而生产环境下，由于 Vite 直接使用 Rollup，Vite 插件中所有 Rollup 的插件钩子都会生效。</p>
<h3>2. 独有 Hook</h3>
<p>接下来给大家介绍 Vite 中特有的一些 Hook，这些 Hook 只会在 Vite 内部调用，而放到 Rollup 中会被直接忽略。</p>
<h4>2.1 给配置再加点料: config</h4>
<p>Vite 在读取完配置文件（即<code>vite.config.ts</code>）之后，会拿到用户导出的配置对象，然后执行 config 钩子。在这个钩子里面，你可以对配置文件导出的对象进行自定义的操作，如下代码所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 返回部分配置（推荐）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">editConfigPlugin</span> = (<span class="hljs-params"></span>) => ({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-modify-config'</span>,
  <span class="hljs-attr">config</span>: <span class="hljs-function">() =></span> ({
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-attr">react</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'react'</span>)
    }
  })
})
</code></pre>
<p>官方推荐的姿势是在 config 钩子中返回一个配置对象，这个配置对象会和 Vite 已有的配置进行深度的合并。不过你也可以通过钩子的入参拿到 config 对象进行自定义的修改，如下代码所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mutateConfigPlugin</span> = (<span class="hljs-params"></span>) => ({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'mutate-config'</span>,
  <span class="hljs-comment">// command 为 `serve`(开发环境) 或者 `build`(生产环境)</span>
  <span class="hljs-title function_">config</span>(<span class="hljs-params">config, { command }</span>) {
    <span class="hljs-comment">// 生产环境中修改 root 参数</span>
    <span class="hljs-keyword">if</span> (command === <span class="hljs-string">'build'</span>) {
      config.<span class="hljs-property">root</span> = __dirname;
    }
  }
})
</code></pre>
<p>在一些比较深层的对象配置中，这种直接修改配置的方式会显得比较麻烦，如 <code>optimizeDeps.esbuildOptions.plugins</code>，需要写很多的样板代码，类似下面这样:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 防止出现 undefined 的情况</span>
config.<span class="hljs-property">optimizeDeps</span> = config.<span class="hljs-property">optimizeDeps</span> || {}
config.<span class="hljs-property">optimizeDeps</span>.<span class="hljs-property">esbuildOptions</span> = config.<span class="hljs-property">optimizeDeps</span>.<span class="hljs-property">esbuildOptions</span> || {}
config.<span class="hljs-property">optimizeDeps</span>.<span class="hljs-property">esbuildOptions</span>.<span class="hljs-property">plugins</span> = config.<span class="hljs-property">optimizeDeps</span>.<span class="hljs-property">esbuildOptions</span>.<span class="hljs-property">plugins</span> || []
</code></pre>
<p>因此这种情况下，建议直接返回一个配置对象，这样会方便很多:</p>
<pre><code class="hljs language-ts"><span class="hljs-title function_">config</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">optimizeDeps</span>: {
      <span class="hljs-attr">esbuildOptions</span>: {
        <span class="hljs-attr">plugins</span>: []
      }
    }
  }
}
</code></pre>
<h4>2.2 记录最终配置: configResolved</h4>
<p>Vite 在解析完配置之后会调用<code>configResolved</code>钩子，这个钩子一般用来记录最终的配置信息，而不建议再修改配置，用法如下图所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">exmaplePlugin</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">let</span> config

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'read-config'</span>,

    <span class="hljs-title function_">configResolved</span>(<span class="hljs-params">resolvedConfig</span>) {
      <span class="hljs-comment">// 记录最终配置</span>
      config = resolvedConfig
    },

    <span class="hljs-comment">// 在其他钩子中可以访问到配置</span>
    <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config)
    }
  }
}
</code></pre>
<h4>2.3 获取 Dev Server 实例: configureServer</h4>
<p>这个钩子仅在<strong>开发阶段</strong>会被调用，用于扩展 Vite 的 Dev Server，一般用于增加自定义 server 中间件，如下代码所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPlugin</span> = (<span class="hljs-params"></span>) => ({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'configure-server'</span>,
  <span class="hljs-title function_">configureServer</span>(<span class="hljs-params">server</span>) {
    <span class="hljs-comment">// 姿势 1: 在 Vite 内置中间件之前执行</span>
    server.<span class="hljs-property">middlewares</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =></span> {
      <span class="hljs-comment">// 自定义请求处理逻辑</span>
    })
    <span class="hljs-comment">// 姿势 2: 在 Vite 内置中间件之后执行 </span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {
      server.<span class="hljs-property">middlewares</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =></span> {
        <span class="hljs-comment">// 自定义请求处理逻辑</span>
      })
    }
  }
})
</code></pre>
<h4>2.4 转换 HTML 内容: transformIndexHtml</h4>
<p>这个钩子用来灵活控制 HTML 的内容，你可以拿到原始的 html 内容后进行任意的转换:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">htmlPlugin</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'html-transform'</span>,
    <span class="hljs-title function_">transformIndexHtml</span>(<span class="hljs-params">html</span>) {
      <span class="hljs-keyword">return</span> html.<span class="hljs-title function_">replace</span>(
        <span class="hljs-regexp">/&#x3C;title>(.*?)&#x3C;/</span>title>/,
        <span class="hljs-string">`&#x3C;title>换了个标题&#x3C;/title>`</span>
      )
    }
  }
}
<span class="hljs-comment">// 也可以返回如下的对象结构，一般用于添加某些标签</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">htmlPlugin</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'html-transform'</span>,
    <span class="hljs-title function_">transformIndexHtml</span>(<span class="hljs-params">html</span>) {
      <span class="hljs-keyword">return</span> {
        html,
        <span class="hljs-comment">// 注入标签</span>
        <span class="hljs-attr">tags</span>: [
          {
            <span class="hljs-comment">// 放到 body 末尾，可取值还有`head`|`head-prepend`|`body-prepend`，顾名思义</span>
            <span class="hljs-attr">injectTo</span>: <span class="hljs-string">'body'</span>,
            <span class="hljs-comment">// 标签属性定义</span>
            <span class="hljs-attr">attrs</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span>, <span class="hljs-attr">src</span>: <span class="hljs-string">'./index.ts'</span> },
            <span class="hljs-comment">// 标签名</span>
            <span class="hljs-attr">tag</span>: <span class="hljs-string">'script'</span>,
          },
        ],
      }
    }
  }
}
</code></pre>
<h4>2.5 热更新处理: handleHotUpdate</h4>
<blockquote>
<p>关于热更新的概念和原理，我们会在下一节具体讲解。</p>
</blockquote>
<p>这个钩子会在 Vite 服务端处理热更新时被调用，你可以在这个钩子中拿到热更新相关的上下文信息，进行热更模块的过滤，或者进行自定义的热更处理。下面是一个简单的例子:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleHmrPlugin</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleHotUpdate</span>(<span class="hljs-params">ctx</span>) {
      <span class="hljs-comment">// 需要热更的文件</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">file</span>)
      <span class="hljs-comment">// 需要热更的模块，如一个 Vue 单文件会涉及多个模块</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">modules</span>)
      <span class="hljs-comment">// 时间戳</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">timestamp</span>)
      <span class="hljs-comment">// Vite Dev Server 实例</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">server</span>)
      <span class="hljs-comment">// 读取最新的文件内容</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">read</span>())
      <span class="hljs-comment">// 自行处理 HMR 事件</span>
      ctx.<span class="hljs-property">server</span>.<span class="hljs-property">ws</span>.<span class="hljs-title function_">send</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'custom'</span>,
        <span class="hljs-attr">event</span>: <span class="hljs-string">'special-update'</span>,
        <span class="hljs-attr">data</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }
      })
      <span class="hljs-keyword">return</span> []
    }
  }
}

<span class="hljs-comment">// 前端代码中加入</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>) {
  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'special-update'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
    <span class="hljs-comment">// 执行自定义更新</span>
    <span class="hljs-comment">// { a: 1 }</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();
  })
}
</code></pre>
<p>以上就是 Vite 独有的五个钩子，我们来重新梳理一下:</p>
<ul>
<li><code>config</code>: 用来进一步修改配置。</li>
<li><code>configResolved</code>: 用来记录最终的配置信息。</li>
<li><code>configureServer</code>: 用来获取 Vite Dev Server 实例，添加中间件。</li>
<li><code>transformIndexHtml</code>: 用来转换 HTML 的内容。</li>
<li><code>handleHotUpdate</code>: 用来进行热更新模块的过滤，或者进行自定义的热更新处理。</li>
</ul>
<h3>3. 插件 Hook 执行顺序</h3>
<p>好，现在我们学习到了 Vite 的通用钩子和独有钩子，估计你现在脑子里面一点乱: 这么多的钩子，到底谁先执行、谁后执行呢？</p>
<p>下面，我们就来复盘一下上述的两类钩子，并且通过一个具体的代码示例来汇总一下所有的钩子。我们可以在 Vite 的脚手架工程中新建 <code>test-hooks-plugin.ts</code>:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// test-hooks-plugin.ts</span>
<span class="hljs-comment">// 注: 请求响应阶段的钩子</span>
<span class="hljs-comment">// 如 resolveId, load, transform, transformIndexHtml在下文介绍</span>
<span class="hljs-comment">// 以下为服务启动和关闭的钩子</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testHookPlugin</span> () {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'test-hooks-plugin'</span>, 
    <span class="hljs-comment">// Vite 独有钩子</span>
    <span class="hljs-title function_">config</span>(<span class="hljs-params">config</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'config'</span>);
    },
    <span class="hljs-comment">// Vite 独有钩子</span>
    <span class="hljs-title function_">configResolved</span>(<span class="hljs-params">resolvedCofnig</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'configResolved'</span>);
    },
    <span class="hljs-comment">// 通用钩子</span>
    <span class="hljs-title function_">options</span>(<span class="hljs-params">opts</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'options'</span>);
      <span class="hljs-keyword">return</span> opts;
    },
    <span class="hljs-comment">// Vite 独有钩子</span>
    <span class="hljs-title function_">configureServer</span>(<span class="hljs-params">server</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'configureServer'</span>);
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
        <span class="hljs-comment">// 手动退出进程</span>
        process.<span class="hljs-title function_">kill</span>(process.<span class="hljs-property">pid</span>, <span class="hljs-string">'SIGTERM'</span>);
      }, <span class="hljs-number">3000</span>)
    },
    <span class="hljs-comment">// 通用钩子</span>
    <span class="hljs-title function_">buildStart</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'buildStart'</span>);
    },
    <span class="hljs-comment">// 通用钩子</span>
    <span class="hljs-title function_">buildEnd</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'buildEnd'</span>);
    },
    <span class="hljs-comment">// 通用钩子</span>
    <span class="hljs-title function_">closeBundle</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'closeBundle'</span>);
    }
}
</code></pre>
<p>将插件加入到 Vite 配置文件中，然后启动，你可以观察到各个 Hook 的执行顺序:</p>
<p><img src="img\bb214998-ae61-11ed-8618-342eb7027b95.jpg" alt="image.png"></p>
<p>由此我们可以梳理出 Vite 插件的执行顺序:</p>
<p><img src="img\bb396719-ae61-11ed-9717-342eb7027b95.jpg" alt="image.png"></p>
<ul>
<li>服务启动阶段: <code>config</code>、<code>configResolved</code>、<code>options</code>、<code>configureServer</code>、<code>buildStart</code></li>
<li>请求响应阶段: 如果是 <code>html</code> 文件，仅执行<code>transformIndexHtml</code>钩子；对于非 HTML 文件，则依次执行<code>resolveId</code>、<code>load</code>和<code>transform</code>钩子。相信大家学过 Rollup 的插件机制，已经对这三个钩子比较熟悉了。</li>
<li>热更新阶段: 执行<code>handleHotUpdate</code>钩子。</li>
<li>服务关闭阶段: 依次执行<code>buildEnd</code>和<code>closeBundle</code>钩子。</li>
</ul>
<h2>插件应用位置</h2>
<p>梳理完 Vite 的各个钩子函数之后，接下来让我们来了解一下 Vite 插件的<strong>应用情景</strong>和<strong>应用顺序</strong>。</p>
<p>默认情况下 Vite 插件同时被用于开发环境和生产环境，你可以通过<code>apply</code>属性来决定应用场景:</p>
<pre><code class="hljs language-ts">{
  <span class="hljs-comment">// 'serve' 表示仅用于开发环境，'build'表示仅用于生产环境</span>
  <span class="hljs-attr">apply</span>: <span class="hljs-string">'serve'</span>
}
</code></pre>
<p><code>apply</code>参数还可以配置成一个函数，进行更灵活的控制:</p>
<pre><code class="hljs language-ts![plugin.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a93a37e0e4344b97b55bd67afe51d511~tplv-k3u1fbpfcp-zoom-1.image)">apply(config, { command }) {
  // 只用于非 SSR 情况下的生产环境构建
  return command === 'build' &#x26;&#x26; !config.build.ssr
}
</code></pre>
<p>同时，你也可以通过<code>enforce</code>属性来指定插件的执行顺序:</p>
<pre><code class="hljs language-ts">{
  <span class="hljs-comment">// 默认为`normal`，可取值还有`pre`和`post`</span>
  <span class="hljs-attr">enforce</span>: <span class="hljs-string">'pre'</span>
}
</code></pre>
<p>Vite 中插件的执行顺序如下图所示:</p>
<p><img src="img\bb4e2894-ae61-11ed-a5d0-342eb7027b95.jpg" alt="plugin.png"></p>
<p>Vite 会依次执行如下的插件:</p>
<blockquote>
</blockquote>
<ul>
<li>Alias (路径别名)相关的插件。</li>
<li>⭐️ 带有 <code>enforce: 'pre'</code> 的用户插件。</li>
<li>Vite 核心插件。</li>
<li>⭐️ 没有 enforce 值的用户插件，也叫<code>普通插件</code>。</li>
<li>Vite 生产环境构建用的插件。</li>
<li>⭐️ 带有 <code>enforce: 'post'</code> 的用户插件。</li>
<li>Vite 后置构建插件(如压缩插件)。</li>
</ul>
<h2>插件开发实战</h2>
<p>接下来我们进入插件开发的实战环节中，在这个部分我们将一起编写两个 Vite 插件，分别是<code>虚拟模块加载插件</code>和<code>Svgr 插件</code>，你将学会从插件开发的常见套路和各种开发技巧。话不多说，让我们现在开始实战吧。</p>
<h3>实战案例 1: 虚拟模块加载</h3>
<p>首先我们来实现一个虚拟模块的加载插件，可能你会有疑问: 什么是虚拟模块呢？</p>
<p>作为构建工具，一般需要处理两种形式的模块，一种存在于真实的磁盘文件系统中，另一种并不在磁盘而在内存当中，也就是<code>虚拟模块</code>。通过虚拟模块，我们既可以把自己手写的一些代码字符串作为单独的模块内容，又可以将内存中某些经过计算得出的<strong>变量</strong>作为模块内容进行加载，非常灵活和方便。接下来让我们通过一些具体的例子来实操一下，首先通过脚手架命令初始化一个<code>react + ts</code>项目:</p>
<pre><code class="hljs language-ts">npm init vite
</code></pre>
<p>然后通过<code>pnpm i</code>安装依赖，接着新建<code>plugins</code>目录，开始插件的开发:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// plugins/virtual-module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;

<span class="hljs-comment">// 虚拟模块名称</span>
<span class="hljs-keyword">const</span> virtualFibModuleId = <span class="hljs-string">'virtual:fib'</span>;
<span class="hljs-comment">// Vite 中约定对于虚拟模块，解析后的路径需要加上`\0`前缀</span>
<span class="hljs-keyword">const</span> resolvedFibVirtualModuleId = <span class="hljs-string">'\0'</span> + virtualFibModuleId;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">virtualFibModulePlugin</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">ResolvedConfig</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-virtual-module'</span>,
    <span class="hljs-title function_">resolveId</span>(<span class="hljs-params">id</span>) {
      <span class="hljs-keyword">if</span> (id === virtualFibModuleId) { 
        <span class="hljs-keyword">return</span> resolvedFibVirtualModuleId;
      }
    },
    <span class="hljs-title function_">load</span>(<span class="hljs-params">id</span>) {
      <span class="hljs-comment">// 加载虚拟模块</span>
      <span class="hljs-keyword">if</span> (id === resolvedFibVirtualModuleId) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'export default function fib(n) { return n &#x3C;= 1 ? n : fib(n - 1) + fib(n - 2); }'</span>;
      }
    }
  }
}
</code></pre>
<p>接着我们在项目中来使用这个插件:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> virtual <span class="hljs-keyword">from</span> <span class="hljs-string">'./plugins/virtual-module.ts'</span>

<span class="hljs-comment">// 配置插件</span>
{
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>(), <span class="hljs-title function_">virtual</span>()]
}
</code></pre>
<p>然后在<code>main.tsx</code>中加入如下的代码:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> fib <span class="hljs-keyword">from</span> <span class="hljs-string">'virtual:fib'</span>;

<span class="hljs-title function_">alert</span>(<span class="hljs-string">`结果: <span class="hljs-subst">${fib(<span class="hljs-number">10</span>)}</span>`</span>)
</code></pre>
<p>这里我们使用了 <code>virtual:fib</code> 这个虚拟模块，虽然这个模块不存在真实的文件系统中，但你打开浏览器后可以发现这个模块导出的函数是可以正常执行的:</p>
<p><img src="img\bb6b9197-ae61-11ed-bff2-342eb7027b95.jpg" alt="image.png"></p>
<p>接着我们来尝试一下如何通过虚拟模块来读取内存中的变量，在<code>virtual-module.ts</code>中增加如下代码:</p>
<pre><code class="hljs language-diff">import { Plugin, ResolvedConfig } from 'vite';

const virtualFibModuleId = 'virtual:fib';
const resolvedFibVirtualModuleId = '\0' + virtualFibModuleId;

<span class="hljs-addition">+ const virtualEnvModuleId = 'virtual:env';</span>
<span class="hljs-addition">+ const resolvedEnvVirtualModuleId = '\0' + virtualEnvModuleId;</span>

export default function virtualFibModulePlugin(): Plugin {
<span class="hljs-addition">+   let config: ResolvedConfig | null = null;</span>
  return {
    name: 'vite-plugin-virtual-fib-module',
<span class="hljs-addition">+     configResolved(c: ResolvedConfig) {</span>
<span class="hljs-addition">+       config = c;</span>
<span class="hljs-addition">+     },</span>
    resolveId(id) {
      if (id <span class="hljs-comment">=== virtualFibModuleId) { </span>
        return resolvedFibVirtualModuleId;
      }
<span class="hljs-addition">+       if (id === virtualEnvModuleId) { </span>
<span class="hljs-addition">+        return resolvedEnvVirtualModuleId;</span>
<span class="hljs-addition">+      }</span>
    },
    load(id) {
      if (id <span class="hljs-comment">=== resolvedFibVirtualModuleId) {</span>
        return 'export default function fib(n) { return n &#x3C;= 1 ? n : fib(n - 1) + fib(n - 2); }';
      }
<span class="hljs-addition">+      if (id === resolvedEnvVirtualModuleId) {</span>
<span class="hljs-addition">+        return `export default ${JSON.stringify(config!.env)}`;</span>
<span class="hljs-addition">+      }</span>
    }
  }
}
</code></pre>
<p>在新增的这些代码中，我们注册了一个新的虚拟模块<code>virtual:env</code>，紧接着我们去项目去使用:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// main.tsx</span>
<span class="hljs-keyword">import</span> env <span class="hljs-keyword">from</span> <span class="hljs-string">'virtual:env'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(env)
</code></pre>
<p><code>virtual:env</code>一般情况下会有类型问题，我们需要增加一个类型声明文件来声明这个模块:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// types/shim.d.ts</span>
<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'virtual:*'</span> {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-built_in">any</span>;
}
</code></pre>
<p>这样就解决了类型报错的问题。接着你可以去浏览器观察一下输出的情况:</p>
<p><img src="img\bb7cd6a2-ae61-11ed-a15d-342eb7027b95.jpg" alt="image.png"></p>
<p>Vite 环境变量能正确地在浏览器中打印出来，说明在内存中计算出来的<code>virtual:env</code>模块的确被成功地加载了。从中你可以看到，虚拟模块的内容完全能够被动态计算出来，因此它的灵活性和可定制程度非常高，实用性也很强，在 Vite 内部的插件被深度地使用，社区当中也有不少知名的插件(如 <code>vite-plugin-windicss</code>、<code>vite-plugin-svg-icons</code>等)也使用了虚拟模块的技术。</p>
<h3>实战案例 2: Svg 组件形式加载</h3>
<p>在一般的项目开发过程中，我们有时候希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性，相比于<code>img</code>标签的引入方式也更加优雅。但 Vite 本身并不支持将 svg 转换为组件的代码，需要我们通过插件来实现。</p>
<p>接下来我们就来写一个 Vite 插件，实现在 React 项目能够通过组件方式来使用 svg 资源。首先安装一下需要的依赖:</p>
<pre><code class="hljs language-bash">pnpm i resolve @svgr/core -D
</code></pre>
<p>接着在<code>plugins</code>目录新建 <code>svgr.ts</code>:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">'resolve'</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SvgrOptions</span> {
  <span class="hljs-comment">// svg 资源模块默认导出，url 或者组件</span>
  <span class="hljs-attr">defaultExport</span>: <span class="hljs-string">'url'</span> | <span class="hljs-string">'component'</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">viteSvgrPlugin</span>(<span class="hljs-params">options: SvgrOptions</span>) {
  <span class="hljs-keyword">const</span> { defaultExport=<span class="hljs-string">'url'</span> } = options;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-svgr'</span>,
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">code ,id</span>) {
      <span class="hljs-comment">// 转换逻辑: svg -> React 组件</span>
    }
  }
}
</code></pre>
<p>让我们先来梳理一下开发需求，用户通过传入<code>defaultExport</code>可以控制 svg 资源的默认导出:</p>
<ul>
<li>当 <code>defaultExport</code>为 <code>component</code>，默认当做组件来使用，即:</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Logo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Logo.svg'</span>

<span class="hljs-comment">// 在组件中直接使用</span>
&#x3C;<span class="hljs-title class_">Logo</span> />
</code></pre>
<ul>
<li>当<code>defaultExports</code>为<code>url</code>，默认当做 url 使用，如果需要用作组件，可以通过<code>具名导入</code>的方式来支持:</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> logoUrl, { <span class="hljs-title class_">ReactComponent</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Logo</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logo.svg'</span>;

<span class="hljs-comment">// url 使用</span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{logoUrl}</span> /></span></span>
<span class="hljs-comment">// 组件方式使用</span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Logo</span> /></span></span>
</code></pre>
<p>明确了需求之后，接下来让我们来整理一下插件开发的整体思路，主要逻辑在 <code>transform</code>钩子中完成，流程如下:</p>
<ul>
<li>
<ol>
<li>根据 id 入参过滤出 svg 资源；</li>
</ol>
</li>
<li>
<ol start="2">
<li>读取 svg 文件内容；</li>
</ol>
</li>
<li>
<ol start="3">
<li>利用 <code>@svgr/core</code> 将 svg 转换为 React 组件代码;</li>
</ol>
</li>
<li>
<ol start="4">
<li>处理默认导出为 url 的情况；</li>
</ol>
</li>
<li>
<ol start="5">
<li>将组件的 jsx 代码转译为浏览器可运行的代码。</li>
</ol>
</li>
</ul>
<p>下面是插件的完整的代码，你可以参考学习:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Plugin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">'resolve'</span>;

interface <span class="hljs-title class_">SvgrOptions</span> {
  <span class="hljs-attr">defaultExport</span>: <span class="hljs-string">'url'</span> | <span class="hljs-string">'component'</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">viteSvgrPlugin</span>(<span class="hljs-params">options: SvgrOptions</span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-keyword">const</span> { defaultExport=<span class="hljs-string">'component'</span> } = options;

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-svgr'</span>,
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-comment">// 1. 根据 id 入参过滤出 svg 资源；</span>
      <span class="hljs-keyword">if</span> (!id.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.svg'</span>)) {
        <span class="hljs-keyword">return</span> code;
      }
      <span class="hljs-keyword">const</span> svgrTransform = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@svgr/core'</span>).<span class="hljs-property">transform</span>;
      <span class="hljs-comment">// 解析 esbuild 的路径，后续转译 jsx 会用到，我们这里直接拿 vite 中的 esbuild 即可</span>
      <span class="hljs-keyword">const</span> esbuildPackagePath = resolve.<span class="hljs-title function_">sync</span>(<span class="hljs-string">'esbuild'</span>, { <span class="hljs-attr">basedir</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'vite'</span>) });
      <span class="hljs-keyword">const</span> esbuild = <span class="hljs-built_in">require</span>(esbuildPackagePath);
      <span class="hljs-comment">// 2. 读取 svg 文件内容；</span>
      <span class="hljs-keyword">const</span> svg = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(id, <span class="hljs-string">'utf8'</span>);
      <span class="hljs-comment">// 3. 利用 `@svgr/core` 将 svg 转换为 React 组件代码</span>
      <span class="hljs-keyword">const</span> svgrResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">svgrTransform</span>(
        svg,
        {},
        { <span class="hljs-attr">componentName</span>: <span class="hljs-string">'ReactComponent'</span> }
      );
      <span class="hljs-comment">// 4. 处理默认导出为 url 的情况</span>
      <span class="hljs-keyword">let</span> componentCode = svgrResult;
      <span class="hljs-keyword">if</span> (defaultExport === <span class="hljs-string">'url'</span>) {
        <span class="hljs-comment">// 加上 Vite 默认的 `export default 资源路径`</span>
        componentCode += code;
        componentCode = componentCode.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'export default ReactComponent'</span>, <span class="hljs-string">'export { ReactComponent }'</span>);
      }
      <span class="hljs-comment">// 5. 利用 esbuild，将组件中的 jsx 代码转译为浏览器可运行的代码;</span>
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> esbuild.<span class="hljs-title function_">transform</span>(componentCode, {
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'jsx'</span>,
      });
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">code</span>: result.<span class="hljs-property">code</span>,
        <span class="hljs-attr">map</span>: <span class="hljs-literal">null</span> <span class="hljs-comment">// TODO</span>
      };
    },
  };
}
</code></pre>
<p>接下来让我们在项目中使用这个插件:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> svgr <span class="hljs-keyword">from</span> <span class="hljs-string">'./plugins/svgr'</span>;

<span class="hljs-comment">// 返回的配置</span>
{
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 省略其它插件</span>
    <span class="hljs-title function_">svgr</span>()
  ]
}
</code></pre>
<p>接着我们在项目中用组件的方式引入 svg:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// App.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Logo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./logo.svg'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Logo</span> /></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>打开浏览器，可以看到组件已经正常显示:</p>
<p><img src="img\bb90f6e1-ae61-11ed-8558-342eb7027b95.jpg" alt="image.png"></p>
<h3>调试技巧</h3>
<p>另外，在开发调试插件的过程，我推荐大家在本地装上<code>vite-plugin-inspect</code>插件，并在 Vite 中使用它:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> inspect <span class="hljs-keyword">from</span> <span class="hljs-string">'vite-plugin-inspect'</span>;

<span class="hljs-comment">// 返回的配置</span>
{
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 省略其它插件</span>
    <span class="hljs-title function_">inspect</span>()
  ]
}
</code></pre>
<p>这样当你再次启动项目时，会发现多出一个调试地址:</p>
<p><img src="img\bba946e9-ae61-11ed-89f2-342eb7027b95.jpg" alt="image.png"></p>
<p>你可以通过这个地址来查看项目中各个模块的编译结果：</p>
<p><img src="img\bbc2fe6a-ae61-11ed-94bb-342eb7027b95.jpg" alt="image.png"></p>
<p>点击特定的文件后，你可以看到这个模块经过各个插件处理后的中间结果，如下图所示:</p>
<p><img src="img\bbdcd483-ae61-11ed-87de-342eb7027b95.jpg" alt="image.png"></p>
<p>通过这个面板，我们可以很清楚地看到相应模块经过插件处理后变成了什么样子，让插件的调试更加方便。</p>
<h2>小结</h2>
<p>好，本节的内容到这里就接近尾声了。本节你需要重点掌握 Vite <strong>插件钩子的含义</strong>、<strong>作用顺序</strong>以及<strong>插件的实战开发</strong>。</p>
<p>首先我通过一个最简单的示例让你对 Vite 插件的结构有了初步的印象，然后对 Vite 中的各种钩子函数进行了介绍，主要包括<code>通用钩子</code>和<code>独有钩子</code>，通用钩子与 Rollup 兼容，而独有钩子在 Rollup 中会被忽略。而由于上一节已经详细介绍了 Rollup 的插件机制，对于通用钩子我们没有继续展开，而是详细介绍了 5 个独有钩子，分别是: <code>config</code>、<code>configResolved</code>、<code>configureServer</code>、<code>transformIndexHtml</code>和<code>handleHotUpdate</code>。不仅如此，我还给你从宏观角度分析了 Vite 插件的作用场景和作用顺序，你可以分别通过<code>apply</code>和<code>enforce</code>两个参数来进行手动的控制。</p>
<p>接下来我们正式进入插件开发实战的环节，实现了<code>虚拟模块加载插件</code>和<code>Svg 组件加载插件</code>，相信你已经对虚拟模块的概念和使用有了直观的了解，也能通过后者的开发过程了解到如何在 Vite 中集成其它的前端编译工具。总体来说，Vite  插件的设计秉承了 Rollup 的插件设计理念，通过一个个语义化的 Hook 来组织，十分简洁和灵活，上手难度并不大，但真正难的地方在于如何利用 Vite 插件去解决实际开发过程的问题，由于篇幅所限，本文的示例并不能覆盖所有的开发场景，你也不必着急，我们会在后面的几个小节中接触到更加高级的开发场景，你也将接触过越来越多的插件，当然，你的插件开发技能也能越来越纯熟。大家继续加油💪🏻！</p>
</div>
</body>
</html>