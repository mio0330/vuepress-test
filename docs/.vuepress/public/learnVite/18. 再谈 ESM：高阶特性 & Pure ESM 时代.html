<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <title>Title</title>-->
    <style>
        body {
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial !important;
}

.markdown-body {
    word-break: break-word;
    line-height: 1.75;
    font-weight: 400;
    font-size: 16px;
    overflow-x: hidden;
    color: #333
}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    line-height: 1.5;
    margin-top: 35px;
    margin-bottom: 10px;
    padding-bottom: 5px
}

.markdown-body h1 {
    font-size: 24px;
    margin-bottom: 5px
}

.markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    font-size: 20px
}

.markdown-body h2 {
    padding-bottom: 12px;
    border-bottom: 1px solid #ececec
}

.markdown-body h3 {
    font-size: 18px;
    padding-bottom: 0
}

.markdown-body h6 {
    margin-top: 5px
}

.markdown-body p {
    line-height: inherit;
    margin-top: 22px;
    margin-bottom: 22px
}

.markdown-body img {
    max-width: 100%
}

.markdown-body hr {
    border: none;
    border-top: 1px solid #ddd;
    margin-top: 32px;
    margin-bottom: 32px
}

.markdown-body code {
    word-break: break-word;
    border-radius: 2px;
    overflow-x: auto;
    background-color: #fff5f5;
    color: #ff502c;
    font-size: .87em;
    padding: .065em .4em
}

.markdown-body code, .markdown-body pre {
    font-family: Menlo, Monaco, Consolas, Courier New, monospace
}

.markdown-body pre {
    overflow: auto;
    position: relative;
    line-height: 1.75
}

.markdown-body pre > code {
    font-size: 12px;
    padding: 15px 12px;
    margin: 0;
    word-break: normal;
    display: block;
    overflow-x: auto;
    color: #333;
    background: #f8f8f8
}

.markdown-body a {
    text-decoration: none;
    color: #0269c8;
    border-bottom: 1px solid #d1e9ff
}

.markdown-body a:active, .markdown-body a:hover {
    color: #275b8c
}

.markdown-body table {
    display: inline-block !important;
    font-size: 12px;
    width: auto;
    max-width: 100%;
    overflow: auto;
    border: 1px solid #f6f6f6
}

.markdown-body thead {
    background: #f6f6f6;
    color: #000;
    text-align: left
}

.markdown-body tr:nth-child(2n) {
    background-color: #fcfcfc
}

.markdown-body td, .markdown-body th {
    padding: 12px 7px;
    line-height: 24px
}

.markdown-body td {
    min-width: 120px
}

.markdown-body blockquote {
    color: #666;
    padding: 1px 23px;
    margin: 22px 0;
    border-left: 4px solid #cbcbcb;
    background-color: #f8f8f8
}

.markdown-body blockquote:after {
    display: block;
    content: ""
}

.markdown-body blockquote > p {
    margin: 10px 0
}

.markdown-body ol, .markdown-body ul {
    padding-left: 28px
}

.markdown-body ol li, .markdown-body ul li {
    margin-bottom: 0;
    list-style: inherit
}

.markdown-body ol li .task-list-item, .markdown-body ul li .task-list-item {
    list-style: none
}

.markdown-body ol li .task-list-item ol, .markdown-body ol li .task-list-item ul, .markdown-body ul li .task-list-item ol, .markdown-body ul li .task-list-item ul {
    margin-top: 0
}

.markdown-body ol ol, .markdown-body ol ul, .markdown-body ul ol, .markdown-body ul ul {
    margin-top: 3px
}

.markdown-body ol li {
    padding-left: 6px
}

.markdown-body .contains-task-list {
    padding-left: 0
}

.markdown-body .task-list-item {
    list-style: none
}

@media (max-width: 720px) {
    .markdown-body h1 {
        font-size: 24px
    }

    .markdown-body h2 {
        font-size: 20px
    }

    .markdown-body h3 {
        font-size: 18px
    }
}
    </style>
</head>
<body>
<div class="markdown-body">
    <p>在小册导读篇的内容当中，我们就已经详细分析过前端模块化的发展历史，谈到 ESM 已经逐步得到各大浏览器厂商以及 Node.js 的原生支持，正在成为主流前端模块化方案。而 Vite 本身就是借助浏览器原生的 ESM 解析能力(<code>type="module"</code>)实现了开发阶段的 <code>no-bundle</code>，即不用打包也可以构建 Web 应用。不过我们对于原生 ESM 的理解仅仅停留在 <code>type="module"</code>这个特性上面未免有些狭隘了，一方面浏览器和 Node.js 各自提供了不同的 ESM 使用特性，如 <code>import maps</code>、package.json 的 <code>imports</code>和<code>exports</code> 属性等等，另一方面前端社区开始逐渐向 ESM 过渡，有的包甚至仅留下 ESM 产物，<code>Pure ESM</code> 的概念随之席卷前端圈，而与此同时，基于 ESM 的 CDN 基础设施也如雨后春笋般不断涌现，诸如<code>esm.sh</code>、<code>skypack</code>、<code>jspm</code>等等。</p>
<p>因此你可以看到，ESM 已经不仅仅局限于一个模块规范的概念，它代表了前端社区生态的走向以及各项前端基础设施的未来，不管是浏览器、Node.js 还是 npm 上第三方包生态的发展，无一不在印证这一点。那么，作为一名 2022 年的前端，我觉得深入地了解 ESM 的高级特性、社区生态都是有必要的，一方面弥补自己对于 ESM 认知上的不足，另一方面也能享受到社区生态带给我们的红利。</p>
<p>在接下来的内容中，我将给你详细介绍浏览器和 Node.js 中基于 ESM 实现的一些<code>高级特性</code>，然后分析什么是 <code>Pure ESM</code> 模式，这种模式下存在哪些痛点，以及我们作为开发者，如何去拥抱<code>Pure ESM</code>的趋势。</p>
<h2>高阶特性</h2>
<h3>import map</h3>
<p>在浏览器中我们可以使用包含<code>type="module"</code>属性的<code>script</code>标签来加载 ES 模块，而模块路径主要包含三种:</p>
<ul>
<li>绝对路径，如 <code>https://cdn.skypack.dev/react</code></li>
<li>相对路径，如<code>./module-a</code></li>
<li><code>bare import</code>即直接写一个第三方包名，如<code>react</code>、<code>lodash</code></li>
</ul>
<p>对于前两种模块路径浏览器是原生支持的，而对于 <code>bare import</code>，在 Node.js 能直接执行，因为 Node.js 的路径解析算法会从项目的 node_modules 找到第三方包的模块路径，但是放在浏览器中无法直接执行。而这种写法在日常开发的过程又极为常见，除了将 bare import 手动替换为一个绝对路径，还有其它的解决方案吗？</p>
<p>答案是有的。现代浏览器内置的 <code>import map</code> 就是为了解决上述的问题，我们可以用一个简单的例子来使用这个特性:</p>
<pre><code class="hljs language-html"><span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>

<span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Document<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>

<span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"importmap"</span>></span><span class="javascript">
  {
    <span class="hljs-string">"imports"</span>: {
      <span class="hljs-string">"react"</span>: <span class="hljs-string">"https://cdn.skypack.dev/react"</span>
    }
  }
  </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>

  <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
    <span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
    <span class="hljs-built_in">console</span>.log(React)
  </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>

<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>
</code></pre>
<p>在浏览器中执行这个 HTML，如果正常执行，那么你可以看到浏览器已经从网络中获取了 react 的内容，如下图所示:</p>
<blockquote>
<p>注意: importmap 可能存在浏览器兼容性问题，这里出现浏览器报错也属于正常情况，后文会介绍解决方案。</p>
</blockquote>
<p><img src="img\c6952bf4-ae61-11ed-9b7c-342eb7027b95.jpg" alt="image.png"></p>
<p>在支持 <code>import map</code>的浏览器中，在遇到<code>type="importmap"</code>的 script 标签时，浏览器会记录下第三方包的路径映射表，在遇到<code>bare import</code>时会根据这张表拉取远程的依赖代码。如上述的例子中，我们使用 <code>skypack</code>这个第三方的 ESM CDN 服务，通过<code>https://cdn.skypack.dev/react</code>这个地址我们可以拿到 React 的 ESM 格式产物。</p>
<p><code>import map</code>特性虽然简洁方便，但浏览器的兼容性却是个大问题，在 CanIUse 上的兼容性数据如下:</p>
<p><img src="img\c6c8a798-ae61-11ed-ad5f-342eb7027b95.jpg" alt="image.png"></p>
<p>它只能兼容市面上 <code>68%</code> 左右的浏览器份额，而反观<code>type="module"</code>的兼容性(兼容 95% 以上的浏览器)，<code>import map</code>的兼容性实属不太乐观。但幸运的是，社区已经有了对应的 Polyfill 解决方案——<a href="https://github.com/guybedford/es-module-shims" target="_blank" rel="nofollow noopener noreferrer">es-module-shims</a>，完整地实现了包含 <code>import map</code>在内的各大 ESM 特性，还包括:</p>
<ol>
<li>
<p><code>dynamic import</code>。即动态导入，部分老版本的 Firefox 和 Edge 不支持。</p>
</li>
<li>
<p><code>import.meta</code>和<code>import.meta.url</code>。当前模块的元信息，类似 Node.js 中的 <code>__dirname</code>、<code>__filename</code>。</p>
</li>
<li>
<p><code>modulepreload</code>。以前我们会在 link 标签中加上 <code>rel="preload"</code> 来进行资源预加载，即在浏览器解析 HTML 之前就开始加载资源，现在对于 ESM 也有对应的<code>modulepreload</code>来支持这个行为。</p>
</li>
<li>
<p><code>JSON Modules</code>和 <code>CSS Modules</code>，即通过如下方式来引入<code>json</code>或者<code>css</code>:</p>
</li>
</ol>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
<span class="hljs-comment">// 获取 json 对象</span>
<span class="hljs-keyword">import</span> json <span class="hljs-keyword">from</span> <span class="hljs-string">'https://site.com/data.json'</span> assert { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };
<span class="hljs-comment">// 获取 CSS Modules 对象</span>
<span class="hljs-keyword">import</span> sheet <span class="hljs-keyword">from</span> <span class="hljs-string">'https://site.com/sheet.css'</span> assert { <span class="hljs-attr">type</span>: <span class="hljs-string">'css'</span> };
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
</code></pre>
<p>值得一提的是，<code>es-module-shims</code> 基于 wasm 实现，性能并不差，相比浏览器原生的行为没有明显的性能下降:</p>
<p><img src="img\c6eebba8-ae61-11ed-9c74-342eb7027b95.jpg" alt="image.png"></p>
<blockquote>
<p>大家可以去<a href="https://github.com/guybedford/es-module-shims/tree/main/bench" target="_blank" rel="nofollow noopener noreferrer">这个地址</a>查看具体的 benchmark 结果。</p>
</blockquote>
<p>由此可见，<code>import map</code>虽然并没有得到广泛浏览器的原生支持，但是我们仍然可以通过 Polyfill 的方式在支持 <code>type="module"</code> 的浏览器中使用 <code>import map</code>。</p>
<h3>Nodejs 包导入导出策略</h3>
<p>在 Node.js 中(<code>>=12.20 版本</code>)有一般如下几种方式可以使用原生 ES Module:</p>
<ul>
<li>文件以 <code>.mjs</code> 结尾；</li>
<li>package.json 中声明<code>type: "module"</code>。</li>
</ul>
<p>那么，Nodejs 在处理 ES Module 导入导出的时候，如果是处理 npm 包级别的情况，其中的细节可能比你想象中更加复杂。</p>
<p>首先来看看如何导出一个包，你有两种方式可以选择: <code>main</code>和 <code>exports</code>属性。这两个属性均来自于<code>package.json</code>，并且根据 Node 官方的 resolve 算法(<a href="http://nodejs.cn/api/esm.html#resolver-algorithm-specification" target="_blank" rel="nofollow noopener noreferrer">查看详情</a>)，exports 的优先级比 main 更高，也就是说如果你同时设置了这两个属性，那么 <code>exports</code>会优先生效。</p>
<p><code>main</code> 的使用比较简单，设置包的入口文件路径即可，如:</p>
<pre><code class="hljs language-json"><span class="hljs-string">"main"</span>: <span class="hljs-string">"./dist/index.js"</span>
</code></pre>
<p>需要重点梳理的是<code>exports</code>属性，它包含了多种导出形式: <code>默认导出</code>、<code>子路径导出</code>和<code>条件导出</code>，这些导出形式如以下的代码所示:</p>
<pre><code class="hljs language-json"><span class="hljs-comment">// package.json</span>
{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"package-a"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"module"</span>,
  <span class="hljs-attr">"exports"</span>: {
    <span class="hljs-comment">// 默认导出，使用方式: import a from 'package-a'</span>
    <span class="hljs-attr">"."</span>: <span class="hljs-string">"./dist/index.js"</span>,
    <span class="hljs-comment">// 子路径导出，使用方式: import d from 'package-a/dist'</span>
    <span class="hljs-attr">"./dist"</span>: <span class="hljs-string">"./dist/index.js"</span>,
    <span class="hljs-attr">"./dist/*"</span>: <span class="hljs-string">"./dist/*"</span>, <span class="hljs-comment">// 这里可以使用 `*` 导出目录下所有的文件</span>
    <span class="hljs-comment">// 条件导出，区分 ESM 和 CommonJS 引入的情况</span>
    <span class="hljs-attr">"./main"</span>: {
      <span class="hljs-attr">"import"</span>: <span class="hljs-string">"./main.js"</span>,
      <span class="hljs-attr">"require"</span>: <span class="hljs-string">"./main.cjs"</span>
    },
  }
}
</code></pre>
<p>其中，条件导出可以包括如下常见的属性:</p>
<ul>
<li><code>node</code>: 在 Node.js 环境下适用，可以定义为嵌套条件导出，如:</li>
</ul>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"exports"</span>: {
    {
      <span class="hljs-attr">"."</span>: {
       <span class="hljs-attr">"node"</span>: {
         <span class="hljs-attr">"import"</span>: <span class="hljs-string">"./main.js"</span>,
         <span class="hljs-attr">"require"</span>: <span class="hljs-string">"./main.cjs"</span>
        }     
      }
    }
  },
}
</code></pre>
<ul>
<li><code>import</code>: 用于 import 方式导入的情况，如<code>import("package-a")</code>;</li>
<li><code>require</code>: 用于 require 方式导入的情况，如<code>require("package-a")</code>;</li>
<li><code>default</code>，兜底方案，如果前面的条件都没命中，则使用 default 导出的路径。</li>
</ul>
<p>当然，条件导出还包含 <code>types</code>、<code>browser</code>、<code>develoment</code>、<code>production</code> 等属性，大家可以参考 Node.js 的<a href="https://nodejs.org/api/packages.html#conditional-exports" target="_blank" rel="nofollow noopener noreferrer">详情文档</a>，这里就不一一赘述了。</p>
<p>在介绍完"导出"之后，我们再来看看<code>"导入"</code>，也就是 package.json 中的 <code>imports</code>字段，一般是这样声明的:</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"imports"</span>: {
    <span class="hljs-comment">// key 一般以 # 开头</span>
    <span class="hljs-comment">// 也可以直接赋值为一个字符串: "#dep": "lodash-es"</span>
    <span class="hljs-attr">"#dep"</span>: {
      <span class="hljs-attr">"node"</span>: <span class="hljs-string">"lodash-es"</span>,
      <span class="hljs-attr">"default"</span>: <span class="hljs-string">"./dep-polyfill.js"</span>
    },
  },
  <span class="hljs-attr">"dependencies"</span>: {
    <span class="hljs-attr">"lodash-es"</span>: <span class="hljs-string">"^4.17.21"</span>
  }
}
</code></pre>
<p>这样你可以在自己的包中使用下面的 import 语句:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> { cloneDeep } <span class="hljs-keyword">from</span> <span class="hljs-string">"#dep"</span>;

<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };

<span class="hljs-comment">// { a: 1 }</span>
<span class="hljs-built_in">console</span>.log(cloneDeep(obj));
</code></pre>
<p>Node.js 在执行的时候会将<code>#dep</code>定位到<code>lodash-es</code>这个第三方包，当然，你也可以将其定位到某个内部文件。这样相当于实现了<code>路径别名</code>的功能，不过与构建工具中的 <code>alias</code> 功能不同的是，"imports" 中声明的别名必须全量匹配，否则 Node.js 会直接抛错。</p>
<h2>Pure ESM</h2>
<p>说完了 ESM 的一些高级特性之后，我们来聊聊社区中一个叫做 <code>Pure ESM</code> 的概念。</p>
<p>首先，什么是 <code>Pure ESM</code> ? <code>Pure ESM</code> 最初是在 Github 上的一个<a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c" target="_blank" rel="nofollow noopener noreferrer">帖子</a>中被提出来的，其中有两层含义，一个是让 npm 包都提供 ESM 格式的产物，另一个是仅留下 ESM 产物，抛弃 CommonJS 等其它格式产物。</p>
<h3>对 Pure ESM 的态度</h3>
<p>当这个概念被提出来之后社区当中出现了很多不同的声音，有人赞成，也有人不满。但不管怎么样，社区中的很多 npm 包已经出现了 <code>ESM First</code> 的趋势，可以预见的是越来越多的包会提供 ESM 的版本，来拥抱社区 ESM 大一统的趋势，同时也有一部分的 npm 包做得更加激进，直接采取<code>Pure ESM</code>模式，如大名鼎鼎的<code>chalk</code>和<code>imagemin</code>，最新版本中只提供 ESM 产物，而不再提供 CommonJS 产物。</p>
<p>对于 Pure ESM，我们到底应该支持还是反对呢？首先抛出我的结论:</p>
<blockquote>
<p>对于没有上层封装需求的大型框架，如 Nuxt、Umi，在保证能上 <code>Pure ESM</code>的情况下，直接上不会有什么问题；但如果是一个底层基础库，最好提供好 ESM 和 CommonJS 两种格式的产物。</p>
</blockquote>
<p>接下来，我们就来分析这个结论是怎么得出来的。</p>
<p>在 ESM 中，我们可以直接导入 CommonJS 模块，如:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// react 仅有 CommonJS 产物</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-built_in">console</span>.log(React)
</code></pre>
<p>Node.js 执行以上的原生 ESM 代码并没有问题，但反过来，如果你想在 CommonJS 中 require 一个 ES 模块，就行不通了:</p>
<p><img src="img\c70a1b38-ae61-11ed-9e68-342eb7027b95.jpg" alt="image.png"></p>
<p>其根本原因在于 require 是同步加载的，而 ES 模块本身具有异步加载的特性，因此两者天然互斥，即我们无法 require 一个 ES 模块。</p>
<p>那是不是在 CommonJS 中无法引入 ES 模块了呢? 也不尽然，我们可以通过 <code>dynamic import</code>来引入:</p>
<p><img src="img\c72451c5-ae61-11ed-90a4-342eb7027b95.jpg" alt="image.png"></p>
<p>不知道你注意到没有，为了引入一个 ES 模块，我们必须要将原来同步的执行环境改为<code>异步</code>的，这就带来如下的几个问题:</p>
<ul>
<li>
<ol>
<li>如果执行环境不支持异步，CommonJS 将无法导入 ES 模块；</li>
</ol>
</li>
<li>
<ol start="2">
<li>jest 中不支持导入 ES 模块，测试会比较困难；</li>
</ol>
</li>
<li>
<ol start="3">
<li>在 tsc 中，对于 <code>await import()</code>语法会强制编译成 <code>require</code>的语法(<a href="https://github.com/microsoft/TypeScript/issues/43329" target="_blank" rel="nofollow noopener noreferrer">详情</a>)，只能靠<code>eval('await import()')</code>绕过去。</li>
</ol>
</li>
</ul>
<p>总而言之，CommonJS 中导入 ES 模块比较困难。因此，如果一个基础底层库使用 <code>Pure ESM</code>，那么潜台词相当于你依赖这个库时(可能是直接依赖，也有可能是间接依赖)，你自己的库/应用的产物最好为 <code>ESM</code> 格式。也就是说，<code>Pure ESM</code>是具有传染性的，底层的库出现了 Pure ESM 产物，那么上层的使用方也最好是 Pure ESM，否则会有上述的种种限制。</p>
<p>但从另一个角度来看，对于大型框架(如 Nuxt)而言，基本没有二次封装的需求，框架本身如果能够使用 Pure ESM ，那么也能带动社区更多的包(比如框架插件)走向 Pure ESM，同时也没有上游调用方的限制，反而对社区 ESM 规范的推动是一件好事情。</p>
<p>当然，上述的结论也带来了一个潜在的问题: 大型框架毕竟很有限，npm 上大部分的包还是属于基础库的范畴，那对于大部分包，我们采用导出 ESM/CommonJS 两种产物的方案，会不会对项目的语法产生限制呢？</p>
<p>我们知道，在 ESM 中无法使用 CommonJS 中的 <code>__dirname</code>、<code>__filename</code>、<code>require.resolve</code> 等全局变量和方法，同样的，在 CommonJS 中我们也没办法使用 ESM 专有的 <code>import.meta</code>对象，那么如果要提供两种产物格式，这些模块规范相关的语法怎么处理呢？</p>
<p>在传统的编译构建工具中，我们很难逃开这个问题，但新一代的基础库打包器<code>tsup</code>给了我们解决方案。</p>
<h3>新一代的基础库打包器</h3>
<p>tsup 是一个基于 Esbuild 的基础库打包器，主打无配置(no config)打包。借助它我们可以轻易地打出 ESM 和 CommonJS 双格式的产物，并且可以任意使用与模块格式强相关的一些全局变量或者 API，比如某个库的源码如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Options {
  <span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">options: Options</span>) </span>{
  <span class="hljs-built_in">console</span>.log(options);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">import</span>.meta.url);
}
</code></pre>
<p>由于代码中使用了 <code>import.meta</code> 对象，这是仅在 ESM 下存在的变量，而经过 tsup 打包后的 CommonJS 版本却被转换成了下面这样:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">var</span> getImportMetaUrl = <span class="hljs-function">() =></span>
  <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">document</span> === <span class="hljs-string">"undefined"</span>
    ? <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"file:"</span> + __filename).href
    : (<span class="hljs-built_in">document</span>.currentScript &#x26;&#x26; <span class="hljs-built_in">document</span>.currentScript.src) ||
      <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"main.js"</span>, <span class="hljs-built_in">document</span>.baseURI).href;
<span class="hljs-keyword">var</span> importMetaUrl = <span class="hljs-comment">/* @__PURE__ */</span> getImportMetaUrl();

<span class="hljs-comment">// src/index.ts</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-built_in">console</span>.log(options);
  <span class="hljs-built_in">console</span>.log(importMetaUrl);
}
</code></pre>
<p>可以看到，ESM 中的 API 被转换为 CommonJS 对应的格式，反之也是同理。最后，我们可以借助之前提到的条件导出，将 ESM、CommonJS 的产物分别进行导出，如下所示:</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"watch"</span>: <span class="hljs-string">"npm run build -- --watch src"</span>,
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsup ./src/index.ts --format cjs,esm --dts --clean"</span>
  },
  <span class="hljs-attr">"exports"</span>: {
    <span class="hljs-attr">"."</span>: {
      <span class="hljs-attr">"import"</span>: <span class="hljs-string">"./dist/index.mjs"</span>,
      <span class="hljs-attr">"require"</span>: <span class="hljs-string">"./dist/index.js"</span>,
      <span class="hljs-comment">// 导出类型</span>
      <span class="hljs-attr">"types"</span>: <span class="hljs-string">"./dist/index.d.ts"</span>
    }
  }
}
</code></pre>
<p>示例的代码我已经放到了 Github 仓库中(<a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/18-esm-advanced" target="_blank" rel="nofollow noopener noreferrer">点击查看</a>)，你可以参考学习。</p>
<p>tsup 在解决了双格式产物问题的同时，本身利用 Esbuild 进行打包，性能非常强悍，也能生成类型文件，同时也弥补了 Esbuild 没有类型系统的缺点，还是非常推荐大家使用的。</p>
<p>当然，回到 <code>Pure ESM</code> 本身，我觉得这是一个未来可以预见的趋势，但对于基础库来说，现在并不适合切到<code>Pure ESM</code>，如今作为过渡时期，还是发 ESM/CommonJS 双格式的包较为靠谱，而<code>tsup</code>这种工具能降低基础库构建上的成本。当所有的库都有 ESM 产物的时候，我们再来落地 <code>Pure ESM</code> 就轻而易举了。</p>
<h2>总结</h2>
<p>好，本小节的内容就到这里，我们来总结和回顾一下。</p>
<p>在最开始的部分我给你介绍了 ESM 在浏览器和 Node.js 中的高级特性，分别包括<code>import map</code> 和<code>npm 导入导出策略</code>。</p>
<p>接着我给你探讨了一下社区的新趋势——<code>Pure ESM</code>，首先跟你介绍了它的基本概念和目前存在的一些问题，并且给你推荐了新一代的基础库构建工具<code>tsup</code>来同时构建 CommonJS 和 ESM 两种格式的产物，来确保第三方库的可用性。我们也期待社区能有越来越多的包提供 ESM 格式，让 Pure ESM 越来越触手可及。</p>
<p>最后，恭喜你完成了本节的学习，欢迎你把这一节的学习收获打在评论区，我们下一节再见👋！</p>
</div>
</body>
</html>