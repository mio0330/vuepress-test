<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <title>Title</title>-->
    <style>
        body {
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial !important;
}

.markdown-body {
    word-break: break-word;
    line-height: 1.75;
    font-weight: 400;
    font-size: 16px;
    overflow-x: hidden;
    color: #333
}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    line-height: 1.5;
    margin-top: 35px;
    margin-bottom: 10px;
    padding-bottom: 5px
}

.markdown-body h1 {
    font-size: 24px;
    margin-bottom: 5px
}

.markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    font-size: 20px
}

.markdown-body h2 {
    padding-bottom: 12px;
    border-bottom: 1px solid #ececec
}

.markdown-body h3 {
    font-size: 18px;
    padding-bottom: 0
}

.markdown-body h6 {
    margin-top: 5px
}

.markdown-body p {
    line-height: inherit;
    margin-top: 22px;
    margin-bottom: 22px
}

.markdown-body img {
    max-width: 100%
}

.markdown-body hr {
    border: none;
    border-top: 1px solid #ddd;
    margin-top: 32px;
    margin-bottom: 32px
}

.markdown-body code {
    word-break: break-word;
    border-radius: 2px;
    overflow-x: auto;
    background-color: #fff5f5;
    color: #ff502c;
    font-size: .87em;
    padding: .065em .4em
}

.markdown-body code, .markdown-body pre {
    font-family: Menlo, Monaco, Consolas, Courier New, monospace
}

.markdown-body pre {
    overflow: auto;
    position: relative;
    line-height: 1.75
}

.markdown-body pre > code {
    font-size: 12px;
    padding: 15px 12px;
    margin: 0;
    word-break: normal;
    display: block;
    overflow-x: auto;
    color: #333;
    background: #f8f8f8
}

.markdown-body a {
    text-decoration: none;
    color: #0269c8;
    border-bottom: 1px solid #d1e9ff
}

.markdown-body a:active, .markdown-body a:hover {
    color: #275b8c
}

.markdown-body table {
    display: inline-block !important;
    font-size: 12px;
    width: auto;
    max-width: 100%;
    overflow: auto;
    border: 1px solid #f6f6f6
}

.markdown-body thead {
    background: #f6f6f6;
    color: #000;
    text-align: left
}

.markdown-body tr:nth-child(2n) {
    background-color: #fcfcfc
}

.markdown-body td, .markdown-body th {
    padding: 12px 7px;
    line-height: 24px
}

.markdown-body td {
    min-width: 120px
}

.markdown-body blockquote {
    color: #666;
    padding: 1px 23px;
    margin: 22px 0;
    border-left: 4px solid #cbcbcb;
    background-color: #f8f8f8
}

.markdown-body blockquote:after {
    display: block;
    content: ""
}

.markdown-body blockquote > p {
    margin: 10px 0
}

.markdown-body ol, .markdown-body ul {
    padding-left: 28px
}

.markdown-body ol li, .markdown-body ul li {
    margin-bottom: 0;
    list-style: inherit
}

.markdown-body ol li .task-list-item, .markdown-body ul li .task-list-item {
    list-style: none
}

.markdown-body ol li .task-list-item ol, .markdown-body ol li .task-list-item ul, .markdown-body ul li .task-list-item ol, .markdown-body ul li .task-list-item ul {
    margin-top: 0
}

.markdown-body ol ol, .markdown-body ol ul, .markdown-body ul ol, .markdown-body ul ul {
    margin-top: 3px
}

.markdown-body ol li {
    padding-left: 6px
}

.markdown-body .contains-task-list {
    padding-left: 0
}

.markdown-body .task-list-item {
    list-style: none
}

@media (max-width: 720px) {
    .markdown-body h1 {
        font-size: 24px
    }

    .markdown-body h2 {
        font-size: 20px
    }

    .markdown-body h3 {
        font-size: 18px
    }
}
    </style>
</head>
<body>
<div class="markdown-body">
    <p>在非常早期的 Web 技术中，大家还是使用 JSP 这种古老的模板语法来编写前端的页面，然后直接将 JSP 文件放到服务端，在服务端填入数据并渲染出完整的页面内容，可以说那个时代的做法是天然的服务端渲染。但随着 AJAX 技术的成熟以及各种前端框架(如 Vue、React)的兴起，前后端分离的开发模式逐渐成为常态，前端只负责页面 UI 及逻辑的开发，而服务端只负责提供数据接口，这种开发方式下的页面渲染也叫<code>客户端渲染</code>(Client Side Render，简称 CSR)。</p>
<p>但客户端渲染也存在着一定的问题，例如首屏加载比较慢、对 SEO 不太友好，因此 SSR (Server Side Render)即服务端渲染技术应运而生，它在保留 CSR 技术栈的同时，也能解决 CSR 的各种问题。</p>
<p>这一节，我们一起来聊聊SSR，说说它的基本原理，以及如何借助 Vite 的各项构建能力实现 SSR，让你体会到 SSR 的各个生命周期是如何串联起来的。</p>
<blockquote>
<p>需要说明的是，本节最终的目的并不是让大家学习某个现有的 SSR 解决方案(如 Nuxt)，或者简单了解一下实现原理，而是教大家如何从底层开始手动搭建一个可以深度定制的 SSR 项目，并且解决各种 SSR 中的工程化问题。</p>
</blockquote>
<h2>SSR 基本概念</h2>
<p>首先我们来分析一下 CSR 的问题，它的 HTML 产物一般是如下的结构:</p>
<pre><code class="hljs language-ts">&#x3C;!DOCTYPE html>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"xxx.css"</span> /></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
  <span class="hljs-comment">&#x3C;!-- 一开始没有页面内容 --></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
  <span class="hljs-comment">&#x3C;!-- 通过 JS 执行来渲染页面 --></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx.chunk.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
</code></pre>
<p>顺便我们也回顾一下浏览器的渲染流程，如下图所示:</p>
<p><img src="img\c38f5c75-ae61-11ed-a83b-342eb7027b95.jpg" alt="image.png"></p>
<p>当浏览器拿到如上的 HTML 内容之后，其实并不能渲染完整的页面内容，因为此时的 body 中基本只有一个空的 div 节点，并没有填入真正的页面内容。而接下来浏览器开始下载并执行 JS 代码，经历了框架初始化、数据请求、DOM 插入等操作之后才能渲染出完整的页面。也就是说，在 CSR 中完整的页面内容本质上通过 JS 代码执行之后才能够渲染。这主要会导致两个方面的问题:</p>
<ul>
<li><strong>首屏加载速度比较慢</strong>。首屏加载需要依赖 JS 的执行，下载和执行 JS 都可能是非常耗时的操作，尤其是在一些网络不佳的场景，或者性能敏感的低端机下。</li>
<li><strong>对 SEO(搜索引擎优化) 不友好</strong>。页面 HTML 没有具体的页面内容，导致搜索引擎爬虫无法获取关键词信息，导致网站排名受到影响。</li>
</ul>
<p>那么 SSR 是如何解决这些问题的呢？</p>
<p>在 SSR 的场景下，服务端生成好<strong>完整的 HTML 内容</strong>，直接返回给浏览器，浏览器能够根据 HTML 渲染出完整的首屏内容，而不需要依赖 JS 的加载，这样一方面能够降低首屏渲染的时间，另一方面也能将完整的页面内容展现给搜索引擎的爬虫，利于 SEO。</p>
<p>当然，SSR 中只能生成页面的内容和结构，并不能完成事件绑定，因此需要在浏览器中执行 CSR 的 JS 脚本，完成事件绑定，让页面拥有交互的能力，这个过程被称作<code>hydrate</code>(翻译为<code>注水</code>或者<code>激活</code>)。同时，像这样服务端渲染 + 客户端 hydrate  的应用也被称为<code>同构应用</code>。</p>
<h2>SSR 生命周期分析</h2>
<p>前面我们提到了 SSR 会在服务端(这里主要指 Node.js 端)提前渲染出完整的 HTML 内容，那这是如何做到的呢？</p>
<p>首先需要保证前端的代码经过编译后放到服务端中能够正常执行，其次在服务端渲染前端组件，生成并组装应用的 HTML。这就涉及到 SSR 应用的两大生命周期: <code>构建时</code>和<code>运行时</code>，我们不妨来仔细梳理一下。</p>
<p>我们先来看看<code>构建时</code>需要做哪些事情:</p>
<ol>
<li><strong>解决模块加载问题</strong>。在原有的构建过程之外，需要加入<code>SSR 构建</code>的过程 ，具体来说，我们需要另外生成一份 <code>CommonJS</code> 格式的产物，使之能在 Node.js 正常加载。当然，随着 Node.js 本身对 ESM 的支持越来越成熟，我们也可以复用前端 ESM 格式的代码，Vite 在开发阶段进行 SSR 构建也是这样的思路。</li>
</ol>
<p><img src="img\c3b8e30d-ae61-11ed-8607-342eb7027b95.jpg" alt="image.png"></p>
<ol start="2">
<li><strong>移除样式代码的引入</strong>。直接引入一行 css 在服务端其实是无法执行的，因为 Node.js 并不能解析 CSS 的内容。但 <code>CSS Modules</code> 的情况除外，如下所示:</li>
</ol>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.module.css'</span>

<span class="hljs-comment">// 这里的 styles 是一个对象，如{ "container": "xxx" }，而不是 CSS 代码</span>
<span class="hljs-built_in">console</span>.log(styles)
</code></pre>
<ol start="3">
<li><strong>依赖外部化(external)</strong>。对于某些第三方依赖我们并不需要使用构建后的版本，而是直接从 <code>node_modules</code> 中读取，比如 <code>react-dom</code>，这样在 <code>SSR 构建</code>的过程中将不会构建这些依赖，从而极大程度上加速 SSR 的构建。</li>
</ol>
<p>对于 SSR 的运行时，一般可以拆分为比较固定的生命周期阶段，简单来讲可以整理为以下几个核心的阶段:</p>
<p><img src="img\c3d176d1-ae61-11ed-8e5c-342eb7027b95.jpg" alt="image.png"></p>
<ul>
<li>
<ol>
<li><strong>加载 SSR 入口模块</strong>。在这个阶段，我们需要确定 SSR 构建产物的入口，即组件的入口在哪里，并加载对应的模块。</li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>进行数据预取</strong>。这时候 Node 侧会通过查询数据库或者网络请求来获取应用所需的数据。</li>
</ol>
</li>
<li>
<ol start="3">
<li><strong>渲染组件</strong>。这个阶段为 SSR 的核心，主要将第 <code>1</code> 步中加载的组件渲染成 HTML 字符串或者 Stream 流。</li>
</ol>
</li>
<li>
<ol start="4">
<li><strong>HTML 拼接</strong>。在组件渲染完成之后，我们需要拼接完整的 HTML 字符串，并将其作为响应返回给浏览器。</li>
</ol>
</li>
</ul>
<p>从上面的分析中你可以发现，SSR 其实是<code>构建</code>和<code>运行时</code>互相配合才能实现的，也就是说，仅靠构建工具是不够的，写一个 Vite 插件严格意义上无法实现 SSR 的能力，我们需要对 Vite 的构建流程做一些整体的调整，并且加入一些服务端运行时的逻辑才能实现。那么接下来，我们就以具体的代码示例来讲解如何在 Vite 中完成 SSR 工程的搭建。</p>
<h2>基于 Vite 搭建 SSR 项目</h2>
<h3>1. SSR 构建 API</h3>
<p>首先 Vite 作为一个构建工具，是如何支持 SSR 构建的呢？换句话说，它是如何让前端的代码也能顺利在 Node.js 中成功跑起来的呢？</p>
<p>可以分为两种情况，在开发环境下，Vite 依然秉承 ESM 模块按需加载即 <code>no-bundle</code>的理念，对外提供了<code>ssrLoadModule</code> API，你可以无需打包项目，将入口文件的路径传入<code>ssrLoadModule</code> 即可:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 加载服务端入口模块</span>
<span class="hljs-keyword">const</span> xxx = <span class="hljs-keyword">await</span> vite.ssrLoadModule(<span class="hljs-string">'/src/entry-server.tsx'</span>)
</code></pre>
<p>而在生产环境下，Vite 会默认进行打包，对于 SSR 构建输出 CommonJS 格式的产物。我们可以在<code>package.json</code>中加入这样类似的构建指令:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"build:ssr"</span>: <span class="hljs-string">"vite build --ssr 服务端入口路径"</span>
}
</code></pre>
<p>这样 Vite 会专门为 SSR 打包出一份构建产物。因此你可以看到，大部分 SSR 构建时的事情，Vite 已经帮我们提供了开箱即用的方案，我们后续直接使用即可。</p>
<h3>2. 项目骨架搭建</h3>
<p>接下来我们正式开始 SSR 项目的搭建，你可以通过脚手架初始化一个<code>react+ts</code>的项目:</p>
<pre><code class="hljs language-js">npm init vite
pnpm i
</code></pre>
<p>删除项目自带的<code>src/main.ts</code>，然后在 src 目录下新建<code>entry-client.tsx</code>和<code>entry-server.tsx</code>两个入口文件:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// entry-client.ts</span>
<span class="hljs-comment">// 客户端入口文件</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>

ReactDOM.hydrate(
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">React.StrictMode</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.StrictMode</span>></span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
)

<span class="hljs-comment">// entry-server.ts</span>
<span class="hljs-comment">// 导出 SSR 组件入口</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./App"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ServerEntry</span>(<span class="hljs-params">props: <span class="hljs-built_in">any</span></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span>/></span></span>
  );
}

<span class="hljs-keyword">export</span> { ServerEntry };
</code></pre>
<p>我们以 Express 框架为例来实现 Node 后端服务，后续的 SSR 逻辑会接入到这个服务中。当然你需要安装以下的依赖:</p>
<pre><code class="hljs language-ts">pnpm i express -S
pnpm i <span class="hljs-meta">@types</span>/express -D
</code></pre>
<p>接着新建<code>src/ssr-server/index.ts</code>:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/ssr-server/index.ts</span>
<span class="hljs-comment">// 后端服务</span>
<span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createServer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> app = express();
  
  app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Node 服务器已启动~'</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'http://localhost:3000'</span>);
  });
}

createServer();
</code></pre>
<p>然后你可以在<code>package.json</code>中添加如下的 <code>scripts</code>:</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-comment">// 开发阶段启动 SSR 的后端服务</span>
    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"nodemon --watch src/ssr-server --exec 'esno src/ssr-server/index.ts'"</span>,
    <span class="hljs-comment">// 打包客户端产物和 SSR 产物</span>
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"npm run build:client &#x26;&#x26; npm run build:server"</span>,
    <span class="hljs-attr">"build:client"</span>: <span class="hljs-string">"vite build --outDir dist/client"</span>,
    <span class="hljs-attr">"build:server"</span>: <span class="hljs-string">"vite build --ssr src/entry-server.tsx --outDir dist/server"</span>,
    <span class="hljs-comment">// 生产环境预览 SSR 效果</span>
    <span class="hljs-attr">"preview"</span>: <span class="hljs-string">"NODE_ENV=production esno src/ssr-server/index.ts"</span>
  },
}
</code></pre>
<p>其中设计到两个额外的工具，给大家解释一下:</p>
<ul>
<li><code>nodemon</code>: 一个监听文件变化自动重启 Node 服务的工具。</li>
<li><code>esno</code>: 类似 <code>ts-node</code> 的工具，用来执行 ts 文件，底层基于 Esbuild 实现。</li>
</ul>
<p>同时你也需要安装这两个依赖:</p>
<pre><code class="hljs language-ts">pnpm i esno nodemon -D
</code></pre>
<p>OK，现在我们就基本上搭建好了基本的项目骨架，接下里我们专注于 SSR 运行时的实现逻辑即可。</p>
<h3>3. SSR 运行时实现</h3>
<p>SSR 作为一种特殊的后端服务，我们可以将其封装成一个中间件的形式，如以下的代码所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> express, { RequestHandler, Express } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;
<span class="hljs-keyword">import</span> { ViteDevServer } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>;

<span class="hljs-keyword">const</span> isProd = process.env.NODE_ENV === <span class="hljs-string">'production'</span>;
<span class="hljs-keyword">const</span> cwd = process.cwd();

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-keyword">let</span> vite: ViteDevServer | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (!isProd) { 
    vite = <span class="hljs-keyword">await</span> (<span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'vite'</span>)).createServer({
      <span class="hljs-attr">root</span>: process.cwd(),
      <span class="hljs-attr">server</span>: {
        <span class="hljs-attr">middlewareMode</span>: <span class="hljs-string">'ssr'</span>,
      }
    })
    <span class="hljs-comment">// 注册 Vite Middlewares</span>
    <span class="hljs-comment">// 主要用来处理客户端资源</span>
    app.use(vite.middlewares);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-comment">// SSR 的逻辑</span>
    <span class="hljs-comment">// 1. 加载服务端入口模块</span>
    <span class="hljs-comment">// 2. 数据预取</span>
    <span class="hljs-comment">// 3. 「核心」渲染组件</span>
    <span class="hljs-comment">// 4. 拼接 HTML，返回响应</span>
  };
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createServer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> app = express();
  <span class="hljs-comment">// 加入 Vite SSR 中间件</span>
  app.use(<span class="hljs-keyword">await</span> createSsrMiddleware(app));

  app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Node 服务器已启动~'</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'http://localhost:3000'</span>);
  });
}

createServer();
</code></pre>
<p>接下来我们把焦点放在中间件内 SSR 的逻辑实现上，首先实现第一步即<code>加载服务端入口模块</code>:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadSsrEntryModule</span>(<span class="hljs-params">vite: ViteDevServer | <span class="hljs-literal">null</span></span>) </span>{
  <span class="hljs-comment">// 生产模式下直接 require 打包后的产物</span>
  <span class="hljs-keyword">if</span> (isProd) {
    <span class="hljs-keyword">const</span> entryPath = path.join(cwd, <span class="hljs-string">'dist/server/entry-server.js'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(entryPath);
  } 
  <span class="hljs-comment">// 开发环境下通过 no-bundle 方式加载</span>
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> entryPath = path.join(cwd, <span class="hljs-string">'src/entry-server.tsx'</span>);
    <span class="hljs-keyword">return</span> vite!.ssrLoadModule(entryPath);
  }
}
</code></pre>
<p>中间件内的逻辑如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-comment">// 省略前面的代码</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">const</span> url = req.originalUrl;
    <span class="hljs-comment">// 1. 服务端入口加载</span>
    <span class="hljs-keyword">const</span> { ServerEntry } = <span class="hljs-keyword">await</span> loadSsrEntryModule(vite);
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>接下来我们来实现服务端的数据预取操作，你可以在<code>entry-server.tsx</code>中添加一个简单的获取数据的函数:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">user</span>: <span class="hljs-string">'xxx'</span> }
}
</code></pre>
<p>然后在 SSR 中间件中完成数据预取的操作:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/ssr-server/index.ts</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-comment">// 省略前面的代码</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">const</span> url = req.originalUrl;
    <span class="hljs-comment">// 1. 服务端入口加载</span>
    <span class="hljs-keyword">const</span> { ServerEntry, fetchData } = <span class="hljs-keyword">await</span> loadSsrEntryModule(vite);
    <span class="hljs-comment">// 2. 预取数据</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchData();
  }
}
</code></pre>
<p>接着我们进入到核心的组件渲染阶段:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/ssr-server/index.ts</span>
<span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-comment">// 省略前面的代码</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">const</span> url = req.originalUrl;
    <span class="hljs-comment">// 1. 服务端入口加载</span>
    <span class="hljs-keyword">const</span> { ServerEntry, fetchData } = <span class="hljs-keyword">await</span> loadSsrEntryModule(vite);
    <span class="hljs-comment">// 2. 预取数据</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchData();
    <span class="hljs-comment">// 3. 组件渲染 -> 字符串</span>
    <span class="hljs-keyword">const</span> appHtml = renderToString(React.createElement(ServerEntry, { data }));
  }
}
</code></pre>
<p>由于在第一步之后我们拿到了入口组件，现在可以调用前端框架的<code>renderToString</code>API 将组件渲染为字符串，组件的具体内容便就此生成了。</p>
<p>OK，目前我们已经拿到了组件的 HTML 以及预取的数据，接下来我们在根目录下的 HTML 中提供相应的插槽，方便内容的替换:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// index.html</span>
&#x3C;!DOCTYPE html>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/src/favicon.svg"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>Vite App<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span><span class="hljs-comment">&#x3C;!-- SSR_APP --></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/entry-client.tsx"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-comment">&#x3C;!-- SSR_DATA --></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
</code></pre>
<p>紧接着我们在 SSR 中间件中补充 HTML 拼接的逻辑:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// src/ssr-server/index.ts</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveTemplatePath</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> isProd ?
    path.join(cwd, <span class="hljs-string">'dist/client/index.html'</span>) :
    path.join(cwd, <span class="hljs-string">'index.html'</span>);
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-comment">// 省略之前的代码</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">const</span> url = req.originalUrl;
    <span class="hljs-comment">// 省略前面的步骤</span>
    <span class="hljs-comment">// 4. 拼接完整 HTML 字符串，返回客户端</span>
    <span class="hljs-keyword">const</span> templatePath = resolveTemplatePath();
    <span class="hljs-keyword">let</span> template = <span class="hljs-keyword">await</span> fs.readFileSync(templatePath, <span class="hljs-string">'utf-8'</span>);
    <span class="hljs-comment">// 开发模式下需要注入 HMR、环境变量相关的代码，因此需要调用 vite.transformIndexHtml</span>
    <span class="hljs-keyword">if</span> (!isProd &#x26;&#x26; vite) {
      template = <span class="hljs-keyword">await</span> vite.transformIndexHtml(url, template);
    }
    <span class="hljs-keyword">const</span> html = template
      .replace(<span class="hljs-string">'&#x3C;!-- SSR_APP -->'</span>, appHtml)
      <span class="hljs-comment">// 注入数据标签，用于客户端 hydrate</span>
      .replace(
        <span class="hljs-string">'&#x3C;!-- SSR_DATA -->'</span>,
        <span class="hljs-string">`&#x3C;script>window.__SSR_DATA__=<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(data)}</span>&#x3C;/script>`</span>
      );
    res.status(<span class="hljs-number">200</span>).setHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>).end(html);
  }
}
</code></pre>
<p>在拼接 HTML 的逻辑中，除了添加页面的具体内容，同时我们也注入了一个挂载全局数据的<code>script</code>标签，这是用来干什么的呢？</p>
<p>在 SSR 的基本概念中我们就提到过，为了激活页面的交互功能，我们需要执行 CSR 的 JavaScript 代码来进行 hydrate 操作，而客户端 hydrate 的时候需要和服务端<code>同步预取后的数据</code>，保证页面渲染的结果和服务端渲染一致，因此，我们刚刚注入的数据 script 标签便派上用场了。由于全局的 window 上挂载服务端预取的数据，我们可以在<code>entry-client.tsx</code>也就是客户端渲染入口中拿到这份数据，并进行 hydrate:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>

<span class="hljs-comment">// @ts-ignore</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-built_in">window</span>.__SSR_DATA__;

ReactDOM.hydrate(
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">React.StrictMode</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}/</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.StrictMode</span>></span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
)
</code></pre>
<p>现在，我们基本开发完了 SSR 核心的逻辑，执行<code>npm run dev</code>启动项目:</p>
<p><img src="img\c3e58581-ae61-11ed-9334-342eb7027b95.jpg" alt="image.png"></p>
<p>打开浏览器后查看页面源码，你可以发现 SSR 生成的 HTML 已经顺利返回了:</p>
<p><img src="img\c3fcc82a-ae61-11ed-9731-342eb7027b95.jpg" alt="image.png"></p>
<h3>4. 生产环境的 CSR 资源处理</h3>
<p>如果你现在执行<code>npm run build</code>及<code>npm run preview</code>进行生产环境的预览，会发现 SSR 可以正常返回内容，但所有的静态资源及 CSR 的代码都失效了:</p>
<p><img src="img\c4299fbd-ae61-11ed-a559-342eb7027b95.jpg" alt="image.png"></p>
<p>不过开发阶段并没有这个问题，这是因为对于开发阶段的静态资源 Vite Dev Server 的中间件已经帮我们处理了，而生产环境所有的资源都已经打包完成，我们需要启用单独的静态资源服务来承载这些资源。这里你可以<code>serve-static</code>中间件来完成这个服务，首先安装对应第三方包:</p>
<pre><code class="hljs language-ts">pnpm i serve-<span class="hljs-keyword">static</span> -S
</code></pre>
<p>接着我们到 server 端注册:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 过滤出页面请求</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchPageUrl</span>(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-keyword">if</span> (url === <span class="hljs-string">'/'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> url = req.originalUrl;
      <span class="hljs-keyword">if</span> (!matchPageUrl(url)) {
        <span class="hljs-comment">// 走静态资源的处理</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> next();
      }
      <span class="hljs-comment">// SSR 的逻辑省略</span>
    } <span class="hljs-keyword">catch</span>(e: <span class="hljs-built_in">any</span>) {
      vite?.ssrFixStacktrace(e);
      <span class="hljs-built_in">console</span>.error(e);
      res.status(<span class="hljs-number">500</span>).end(e.message);
    }
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createServer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> app = express();
  <span class="hljs-comment">// 加入 Vite SSR 中间件</span>
  app.use(<span class="hljs-keyword">await</span> createSsrMiddleware(app));

  <span class="hljs-comment">// 注册中间件，生产环境端处理客户端资源</span>
  <span class="hljs-keyword">if</span> (isProd) {
    app.use(serve(path.join(cwd, <span class="hljs-string">'dist/client'</span>)))
  }
  <span class="hljs-comment">// 省略其它代码</span>
}
</code></pre>
<p>这样一来，我们就解决了生产环境下静态资源失效的问题。不过，一般情况下，我们会将静态资源部上传到 CDN 上，并且将 Vite 的 <code>base</code> 配置为域名前缀，这样我们可以通过 CDN 直接访问到静态资源，而不需要加上服务端的处理。不过作为本地的生产环境预览而言，<code>serve-static</code>还是一个不错的静态资源处理手段。</p>
<h2>工程化问题</h2>
<p>以上我们基本实现了 SSR 核心的<code>构建</code>和<code>运行时</code>功能，可以初步运行一个基于 Vite 的 SSR 项目，但在实际的场景中仍然是有不少的工程化问题需要我们注意。下面我就和你一起梳理一下到底需要考虑哪些问题，以及相应的解决思路是如何的，同时我也会推荐一些比较成熟的解决方案。</p>
<h3>1. 路由管理</h3>
<p>在 SPA 场景下，对于不同的前端框架，一般会有不同的路由管理方案，如 Vue 中的 <code>vue-router</code>、React 的<code>react-router</code>。不过归根结底，路由方案在 SSR 过程中所完成的功能都是差不多的:</p>
<ol>
<li>
<p>告诉框架现在渲染哪个路由。在 Vue 中我们可以通过 <code>router.push</code> 确定即将渲染的路由，React 中则通过 <code>StaticRouter</code> 配合<code>location</code>参数来完成。</p>
</li>
<li>
<p>设置 <code>base</code> 前缀。规定路径的前缀，如<code>vue-router</code> 中 <a href="https://router.vuejs.org/zh/guide/migration/#%E7%A7%BB%E5%8A%A8%E4%BA%86-base-%E9%85%8D%E7%BD%AE" target="_blank" rel="nofollow noopener noreferrer">base 参数</a>、<code>react-router</code>中<code>StaticRouter</code>组件的 <a href="https://v5.reactrouter.com/web/api/StaticRouter" target="_blank" rel="nofollow noopener noreferrer">basename</a>。</p>
</li>
</ol>
<h3>2. 全局状态管理</h3>
<p>对于全局的状态管理而言，对于不同的框架也有不同的生态和方案，比如 Vue 中的 <a href="https://vuex.vuejs.org/" target="_blank" rel="nofollow noopener noreferrer">Vuex</a>、<a href="https://pinia.vuejs.org/" target="_blank" rel="nofollow noopener noreferrer">Pinia</a>，React 中的 <a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="nofollow noopener noreferrer">Redux</a>、<a href="https://recoiljs.org/zh-hans/" target="_blank" rel="nofollow noopener noreferrer">Recoil</a>。各个状态管理工具的用法并不是本文的重点，接入 SSR 的思路也比较简单，在<code>预取数据</code>阶段初始化服务端的 <code>store</code> ，将异步获取的数据存入 <code>store</code> 中，然后在 <code>拼接 HTML</code>阶段将数据从 store 中取出放到数据 script 标签中，最后在客户端 hydrate 的时候通过 window 即可访问到预取数据。</p>
<blockquote>
<p>需要注意的服务端处理许多不同的请求，对于每个请求都需要<strong>分别</strong>初始化 store，即一个请求一个 store，不然会造成全局状态污染的问题。</p>
</blockquote>
<h3>3. CSR 降级</h3>
<p>在某些比较极端的情况下，我们需要降级到 CSR，也就是客户端渲染。一般而言包括如下的降级场景:</p>
<ul>
<li>
<ol>
<li>服务器端<strong>预取数据</strong>失败，需要降级到客户端获取数据。</li>
</ol>
</li>
<li>
<ol start="2">
<li>服务器出现异常，需要返回<strong>兜底的 CSR 模板</strong>，完全降级为 CSR。</li>
</ol>
</li>
<li>
<ol start="3">
<li>本地<strong>开发调试</strong>，有时需要跳过 SSR，仅进行 CSR。</li>
</ol>
</li>
</ul>
<p>对于第一种情况，在客户端入口文件中需要有重新获取数据的逻辑，我们可以进行这样的补充:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// entry-client.tsx</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 客户端获取数据</span>
}


<span class="hljs-keyword">async</span> fucntion <span class="hljs-function"><span class="hljs-title">hydrate</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">let</span> data;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.__SSR_DATA__) {
    data = <span class="hljs-built_in">window</span>.__SSR_DATA__;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 降级逻辑 </span>
    data = <span class="hljs-keyword">await</span> fetchData();
  }
  <span class="hljs-comment">// 也可简化为 const data = window.__SSR_DATA__ ?? await fetchData();</span>
  ReactDOM.hydrate(
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">React.StrictMode</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}/</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.StrictMode</span>></span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
  )
}
</code></pre>
<p>对于第二种场景，即<code>服务器执行出错</code>，我们可以在之前的 SSR 中间件逻辑追加 catch 逻辑:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// SSR 的逻辑省略</span>
    } <span class="hljs-keyword">catch</span>(e: <span class="hljs-built_in">any</span>) {
      vite?.ssrFixStacktrace(e);
      <span class="hljs-built_in">console</span>.error(e);
      <span class="hljs-comment">// 在这里返回浏览器 CSR 模板内容</span>
    }
  }
}
</code></pre>
<p>对于第三种情况，我们可以通过通过 <code>?csr</code> 的 url query 参数来强制跳过 SSR，在 SSR 中间件添加如下逻辑:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSsrMiddleware</span>(<span class="hljs-params">app: Express</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">RequestHandler</span>> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (req.query?.csr) {
        <span class="hljs-comment">// 响应 CSR 模板内容</span>
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-comment">// SSR 的逻辑省略</span>
    } <span class="hljs-keyword">catch</span>(e: <span class="hljs-built_in">any</span>) {
      vite?.ssrFixStacktrace(e);
      <span class="hljs-built_in">console</span>.error(e);
    }
  }
}
</code></pre>
<h3>4. 浏览器 API 兼容</h3>
<p>由于 Node.js 中不能使用浏览器里面诸如 <code>window</code>、<code>document</code>之类的 API，因此一旦在服务端执行到这样的 API 会报如下的错误：</p>
<p><img src="img\c43aed4a-ae61-11ed-821a-342eb7027b95.jpg" alt="image.png"></p>
<p>那么如何来解决这个问题呢？</p>
<p>首先我们可以通过<code>import.meta.env.SSR</code>这个 Vite 内置的环境变量来判断是否处于 SSR 环境，以此来规避业务代码在服务端出现浏览器的 API:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.meta.env.SSR) {
  <span class="hljs-comment">// 服务端执行的逻辑</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 在此可以访问浏览器的 API</span>
}
</code></pre>
<p>当然，我们也可以通过 polyfill 的方式，在 Node 中注入浏览器的 API，使这些 API 能够正常运行起来，解决如上的问题。我推荐使用一个比较成熟的 polyfill 库 <code>jsdom</code>，使用方式如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> jsdom = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsdom'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-built_in">window</span> } = <span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">`&#x3C;!DOCTYPE html>&#x3C;p>Hello world&#x3C;/p>`</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-built_in">document</span> } = <span class="hljs-built_in">window</span>;
<span class="hljs-comment">// 挂载到 node 全局</span>
<span class="hljs-built_in">global</span>.window = <span class="hljs-built_in">window</span>;
<span class="hljs-built_in">global</span>.document = <span class="hljs-built_in">document</span>;
</code></pre>
<h3>5. 自定义 Head</h3>
<p>在 SSR 的过程中，我们虽然可以在决定组件的内容，即<code>&#x3C;div id="root">&#x3C;/div></code>这个容器 div 中的内容，但对于 HTML 中<code>head</code>的内容我们无法根据<strong>组件的内部状态</strong>来决定，比如对于一个直播间的页面，我们需要在服务端渲染出 title 标签，title 的内容是不同主播的直播间名称，不能在代码中写死，这种情况怎么办？</p>
<p>React 生态中的 <a href="https://github.com/nfl/react-helmet" target="_blank" rel="nofollow noopener noreferrer">react-helmet</a> 以及 Vue 生态中的 <a href="https://github.com/nuxt/vue-meta" target="_blank" rel="nofollow noopener noreferrer">vue-meta</a> 库就是为了解决这样的问题，让我们可以直接在组件中写一些 Head 标签，然后在服务端能够拿到组件内部的状态。这里我以一个<code>react-helmet</code>例子来说明:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 前端组件逻辑</span>
<span class="hljs-keyword">import</span> { Helmet } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-helmet"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> { data } = props;
  <span class="hljs-keyword">return</span> {
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
       <span class="hljs-tag">&#x3C;<span class="hljs-name">Helmet</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>{ data.user }的页面<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"canonical"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://mysite.com/example"</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Helmet</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  }
}
<span class="hljs-comment">// 服务端逻辑</span>
<span class="hljs-keyword">import</span> Helmet <span class="hljs-keyword">from</span> <span class="hljs-string">'react-helmet'</span>;

<span class="hljs-comment">// renderToString 执行之后</span>
<span class="hljs-keyword">const</span> helmet = Helmet.renderStatic();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"title 内容: "</span>, helmet.title.toString());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"link 内容: "</span>, helmet.link.toString())
</code></pre>
<p>启动服务后访问页面，可以发现终端能打印出如下的信息:</p>
<p><img src="img\c4572f19-ae61-11ed-bb00-342eb7027b95.jpg" alt="image.png"></p>
<p>如此一来，我们就能根据组件的状态确定 Head 内容，然后在<code>拼接 HTML</code>阶段将这些内容插入到模板中。</p>
<h3>6. 流式渲染</h3>
<p>在不同前端框架的底层都实现了流式渲染的能力，即边渲染边响应，而不是等整个组件树渲染完毕之后再响应，这么做可以让响应提前到达浏览器，提升首屏的加载性能。Vue 中的 <a href="https://www.npmjs.com/package/@vue/server-renderer" target="_blank" rel="nofollow noopener noreferrer">renderToNodeStream</a> 和 React 中的 <a href="https://reactjs.org/docs/react-dom-server.html#rendertonodestream" target="_blank" rel="nofollow noopener noreferrer">renderToNodeStream</a> 都实现了流式渲染的能力, 大致的使用方式如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { renderToNodeStream } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>;

<span class="hljs-comment">// 返回一个 Nodejs 的 Stream 对象</span>
<span class="hljs-keyword">const</span> stream = renderToNodeStream(element);
<span class="hljs-keyword">let</span> html = <span class="hljs-string">''</span>

stream.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">data</span> =></span> {
  html += data.toString()
  <span class="hljs-comment">// 发送响应</span>
})

stream.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-built_in">console</span>.log(html) <span class="hljs-comment">// 渲染完成</span>
  <span class="hljs-comment">// 发送响应</span>
})

stream.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">err</span> =></span> {
  <span class="hljs-comment">// 错误处理</span>
})
</code></pre>
<p>不过，流式渲染在我们带来首屏性能提升的同时，也给我们带来了一些限制: <strong>如果我们需要在 HTML 中填入一些与组件状态相关的内容，则不能使用流式渲染</strong>。比如<code>react-helmet</code>中自定义的 head 内容，即便在渲染组件的时候收集到了 head 信息，但在流式渲染中，此时 HTML 的 head 部分已经发送给浏览器了，而这部分响应内容已经无法更改，因此 <code>react-helmet</code> 在 SSR 过程中将会失效。</p>
<h3>7. SSR 缓存</h3>
<p>SSR 是一种典型的 CPU 密集型操作，为了尽可能降低线上机器的负载，设置缓存是一个非常重要的环节。在 SSR 运行时，缓存的内容可以分为这么几个部分:</p>
<ul>
<li><code>文件读取缓存</code>。尽可能避免多次重复读磁盘的操作，每次磁盘 IO 尽可能地复用缓存结果。如下代码所示:</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMemoryFsRead</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> fileContentMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (filePath) => {
    <span class="hljs-keyword">const</span> cacheResult = fileContentMap.get(filePath);
    <span class="hljs-keyword">if</span> (cacheResult) {
      <span class="hljs-keyword">return</span> cacheResult;
    }
    <span class="hljs-keyword">const</span> fileContent = <span class="hljs-keyword">await</span> fs.readFile(filePath);
    fileContentMap.set(filePath, fileContent);
    <span class="hljs-keyword">return</span> fileContent;
  }
}

<span class="hljs-keyword">const</span> memoryFsRead = createMemoryFsRead();
memoryFsRead(<span class="hljs-string">'file1'</span>);
<span class="hljs-comment">// 直接复用缓存</span>
memoryFsRead(<span class="hljs-string">'file1'</span>);
</code></pre>
<ul>
<li>
<p><code>预取数据缓存</code>。对于某些实时性不高的接口数据，我们可以采取缓存的策略，在下次相同的请求进来时复用之前预取数据的结果，这样预取数据过程的各种 IO 消耗，也可以一定程度上减少首屏时间。</p>
</li>
<li>
<p><code>HTML 渲染缓存</code>。拼接完成的<code>HTML</code>内容是缓存的重点，如果能将这部分进行缓存，那么下次命中缓存之后，将可以节省 <code>renderToString</code>、<code>HTML 拼接</code>等一系列的消耗，服务端的性能收益会比较明显。</p>
</li>
</ul>
<p>对于以上的缓存内容，具体的缓存位置可以是：</p>
<ul>
<li>
<ol>
<li><code>服务器内存</code>。如果是放到内存中，需要考虑缓存淘汰机制，防止内存过大导致服务宕机，一个典型的缓存淘汰方案是 <a href="https://github.com/isaacs/node-lru-cache" target="_blank" rel="nofollow noopener noreferrer">lru-cache</a> (基于 LRU 算法)。</li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="https://github.com/redis/node-redis" target="_blank" rel="nofollow noopener noreferrer">Redis 数据库</a>，相当于以传统后端服务器的设计思路来处理缓存。</li>
</ol>
</li>
<li>
<ol start="3">
<li>CDN 服务。我们可以将页面内容缓存到 CDN 服务上，在下一次相同的请求进来时，使用 CDN 上的缓存内容，而不用消费源服务器的资源。对于 CDN 上的 SSR 缓存，大家可以通过阅读<a href="https://juejin.cn/post/6887884087915184141#heading-8" target="_blank" rel="nofollow noopener noreferrer">这篇文章</a>深入了解。</li>
</ol>
</li>
</ul>
<blockquote>
<p>需要补充的是，Vue 中另外实现了<a href="https://ssr.vuejs.org/zh/guide/caching.html#%E7%BB%84%E4%BB%B6%E7%BA%A7%E5%88%AB%E7%BC%93%E5%AD%98-component-level-caching" target="_blank" rel="nofollow noopener noreferrer">组件级别的缓存</a>，这部分缓存一般放在内存中，可以实现更细粒度的 SSR 缓存。</p>
</blockquote>
<h3>8. 性能监控</h3>
<p>在实际的 SSR 项目中，我们时常会遇到一些 SSR 线上性能问题，如果没有一个完整的性能监控机制，那么将很难发现和排查问题。对于 SSR 性能数据，有一些比较通用的指标:</p>
<ul>
<li>SSR 产物加载时间</li>
<li>数据预取的时间</li>
<li>组件渲染的时间</li>
<li>服务端接受请求到响应的完整时间</li>
<li>SSR 缓存命中情况</li>
<li>SSR 成功率、错误日志</li>
</ul>
<p>我们可以通过<code>perf_hooks</code>来完成数据的采集，如下代码所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { performance, PerformanceObserver } <span class="hljs-keyword">from</span> <span class="hljs-string">'perf_hooks'</span>;

<span class="hljs-comment">// 初始化监听器逻辑</span>
<span class="hljs-keyword">const</span> perfObserver = <span class="hljs-keyword">new</span> PerformanceObserver(<span class="hljs-function">(<span class="hljs-params">items</span>) =></span> {
  items.getEntries().forEach(<span class="hljs-function"><span class="hljs-params">entry</span> =></span> { 
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'[performance]'</span>, entry.name, entry.duration.toFixed(<span class="hljs-number">2</span>), <span class="hljs-string">'ms'</span>);
  });
  performance.clearMarks();
});

perfObserver.observe({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"measure"</span>] })

<span class="hljs-comment">// 接下来我们在 SSR 进行打点</span>
<span class="hljs-comment">// 以 renderToString  为例</span>
performance.mark(<span class="hljs-string">'render-start'</span>);
<span class="hljs-comment">// renderToString 代码省略</span>
performance.mark(<span class="hljs-string">'render-end'</span>);
performance.measure(<span class="hljs-string">'renderToString'</span>, <span class="hljs-string">'render-start'</span>, <span class="hljs-string">'render-end'</span>);
</code></pre>
<p>接着我们启动服务后访问，可以看到如下的打点日志信息:</p>
<p><img src="img\c4809e19-ae61-11ed-861a-342eb7027b95.jpg" alt="image.png"></p>
<p>同样的，我们可以将其它阶段的指标通过上述的方式收集起来，作为性能日志；另一方面，在生产环境下，我们一般需要结合具体的性能监控平台，对上述的各项指标进行打点上报，完成线上的 SSR 性能监控服务。</p>
<h3>9. SSG/ISR/SPR</h3>
<p>有时候对于一些静态站点(如博客、文档)，不涉及到动态变化的数据，因此我们并不需要用上服务端渲染。此时只需要在构建阶段产出完整的 HTML 进行部署即可，这种构建阶段生成 HTML 的做法也叫<code>SSG</code>(Static Site Generation，静态站点生成)。</p>
<p>SSG 与 SSR 最大的区别就是产出 HTML 的时间点从 SSR <code>运行时</code>变成了<code>构建时</code>，但核心的生命周期流程并没有发生变化:</p>
<p><img src="img\c4998c77-ae61-11ed-85b6-342eb7027b95.jpg" alt="image.png"></p>
<p>这里给一段简单的实现代码:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// scripts/ssg.ts</span>
<span class="hljs-comment">// 以下的工具函数均可以从 SSR 流程复用</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ssg</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 1. 加载服务端入口</span>
  <span class="hljs-keyword">const</span> { ServerEntry, fetchData } = <span class="hljs-keyword">await</span> loadSsrEntryModule(<span class="hljs-literal">null</span>);
  <span class="hljs-comment">// 2. 数据预取</span>
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchData();
  <span class="hljs-comment">// 3. 组件渲染</span>
  <span class="hljs-keyword">const</span> appHtml = renderToString(React.createElement(ServerEntry, { data }));
  <span class="hljs-comment">// 4. HTML 拼接</span>
  <span class="hljs-keyword">const</span> template = <span class="hljs-keyword">await</span> resolveTemplatePath();
  <span class="hljs-keyword">const</span> templateHtml = <span class="hljs-keyword">await</span> fs.readFileSync(template, <span class="hljs-string">'utf-8'</span>);
  <span class="hljs-keyword">const</span> html = templateHtml
  .replace(<span class="hljs-string">'&#x3C;!-- SSR_APP -->'</span>, appHtml)
  .replace(
    <span class="hljs-string">'&#x3C;!-- SSR_DATA -->'</span>,
    <span class="hljs-string">`&#x3C;script>window.__SSR_DATA__=<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(data)}</span>&#x3C;/script>`</span>
  ); 
  <span class="hljs-comment">// 最后，我们需要将 HTML 的内容写到磁盘中，将其作为构建产物</span>
  fs.mkdirSync(<span class="hljs-string">'./dist/client'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });
  fs.writeFileSync(<span class="hljs-string">'./dist/client/index.html'</span>, html);
}

ssg();
</code></pre>
<p>接着你可以在<code>package.json</code>中加入这样一段 npm scripts:</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"build:ssg"</span>: <span class="hljs-string">"npm run build &#x26;&#x26; NODE_ENV=production esno scripts/ssg.ts"</span>  
  }
}
</code></pre>
<p>这样我们便初步实现了 SSG 的逻辑。当然，除了 SSG，业界还流传着一些其它的渲染模式，诸如<code>SPR</code>、<code>ISR</code>，听起来比较高大上，但实际上只是 SSR 和 SSG 所衍生出来的新功能罢了，这里简单给大家解释一下:</p>
<ul>
<li>
<p><code>SPR</code>即<code>Serverless Pre Render</code>，即把 SSR 的服务部署到 Serverless(FaaS) 环境中，实现服务器实例的自动扩缩容，降低服务器运维的成本。</p>
</li>
<li>
<p><code>ISR</code>即<code>Incremental Site Rendering</code>，即增量站点渲染，将一部分的 SSG 逻辑从构建时搬到了 <code>SSR</code> 运行时，解决的是大量页面 SSG 构建耗时长的问题。</p>
</li>
</ul>
<h2>小结</h2>
<p>恭喜你，学习完了 <code>Vite SSR</code> 小节的内容。在本小节中，你需要重点掌握 <strong>Vite 中 SSR 项目的搭建</strong>和 <strong>SSR 工程化问题及其对应的解决方案</strong>。</p>
<p>首先，我给你介绍了 SSR 的基本概念，先分析传统的 CSR 到底存在哪些问题，然后介绍 SSR 是如何解决这些问题的。接着我给你分析了 SSR 应用的生命周期，主要包含<code>构建时</code>和<code>运行时</code>两个部分，带你从宏观上了解了要实现 SSR 究竟需要做哪些事情。当然，光介绍概念是远远不够的，在接下来的时间，我用具体的项目示例带你一步步搭建起了一个简单的 SSR 工程，借助 <code>Vite</code>实现了<code>客户端产物</code>与<code>SSR 产物</code>的构建，然后通过 SSR 中间件的开发实现了 SSR 运行时的逻辑，包括<code>加载服务端入口</code>、<code>数据预取</code>、<code>组件渲染</code>和<code>HTML 拼接</code>这四个核心的步骤。</p>
<p>虽然说基于示例代码我们可以搭建 Vite 的 SSR 项目，但面对实际的开发场景，我们仍然需要考虑诸多的工程化问题，你可以参考下面这张图:</p>
<p><img src="img\c4b2257d-ae61-11ed-89cc-342eb7027b95.jpg" alt="image.png"></p>
<p>其中包括<code>路由管理</code>、<code>状态管理</code>、<code>CSR 降级</code>、<code>浏览器 API 的 SSR 兼容</code>、<code>自定义 Head</code>、<code>流式渲染</code>、<code>SSR 缓存</code>、<code>性能监控</code>以及更多的预渲染模式<code>SSG/SPR/ISR</code>。在后面的篇幅，我带你详细梳理了这些问题，分析各个问题的出现场景，并给出一些比较通用的解决思路和解决方案。相信通过这部分的学习，你也能驾驭更加复杂的 SSR 开发场景了。</p>
<p>OK，本文的内容到这里就结束了，希望能对你有所启发，也欢迎你把自己的学习心得和收获打在评论区，我们下一节再见👋🏻。</p>
</div>
</body>
</html>