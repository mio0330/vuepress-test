<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <title>Title</title>-->
    <style>
        body {
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial !important;
}

.markdown-body {
    word-break: break-word;
    line-height: 1.75;
    font-weight: 400;
    font-size: 16px;
    overflow-x: hidden;
    color: #333
}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    line-height: 1.5;
    margin-top: 35px;
    margin-bottom: 10px;
    padding-bottom: 5px
}

.markdown-body h1 {
    font-size: 24px;
    margin-bottom: 5px
}

.markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    font-size: 20px
}

.markdown-body h2 {
    padding-bottom: 12px;
    border-bottom: 1px solid #ececec
}

.markdown-body h3 {
    font-size: 18px;
    padding-bottom: 0
}

.markdown-body h6 {
    margin-top: 5px
}

.markdown-body p {
    line-height: inherit;
    margin-top: 22px;
    margin-bottom: 22px
}

.markdown-body img {
    max-width: 100%
}

.markdown-body hr {
    border: none;
    border-top: 1px solid #ddd;
    margin-top: 32px;
    margin-bottom: 32px
}

.markdown-body code {
    word-break: break-word;
    border-radius: 2px;
    overflow-x: auto;
    background-color: #fff5f5;
    color: #ff502c;
    font-size: .87em;
    padding: .065em .4em
}

.markdown-body code, .markdown-body pre {
    font-family: Menlo, Monaco, Consolas, Courier New, monospace
}

.markdown-body pre {
    overflow: auto;
    position: relative;
    line-height: 1.75
}

.markdown-body pre > code {
    font-size: 12px;
    padding: 15px 12px;
    margin: 0;
    word-break: normal;
    display: block;
    overflow-x: auto;
    color: #333;
    background: #f8f8f8
}

.markdown-body a {
    text-decoration: none;
    color: #0269c8;
    border-bottom: 1px solid #d1e9ff
}

.markdown-body a:active, .markdown-body a:hover {
    color: #275b8c
}

.markdown-body table {
    display: inline-block !important;
    font-size: 12px;
    width: auto;
    max-width: 100%;
    overflow: auto;
    border: 1px solid #f6f6f6
}

.markdown-body thead {
    background: #f6f6f6;
    color: #000;
    text-align: left
}

.markdown-body tr:nth-child(2n) {
    background-color: #fcfcfc
}

.markdown-body td, .markdown-body th {
    padding: 12px 7px;
    line-height: 24px
}

.markdown-body td {
    min-width: 120px
}

.markdown-body blockquote {
    color: #666;
    padding: 1px 23px;
    margin: 22px 0;
    border-left: 4px solid #cbcbcb;
    background-color: #f8f8f8
}

.markdown-body blockquote:after {
    display: block;
    content: ""
}

.markdown-body blockquote > p {
    margin: 10px 0
}

.markdown-body ol, .markdown-body ul {
    padding-left: 28px
}

.markdown-body ol li, .markdown-body ul li {
    margin-bottom: 0;
    list-style: inherit
}

.markdown-body ol li .task-list-item, .markdown-body ul li .task-list-item {
    list-style: none
}

.markdown-body ol li .task-list-item ol, .markdown-body ol li .task-list-item ul, .markdown-body ul li .task-list-item ol, .markdown-body ul li .task-list-item ul {
    margin-top: 0
}

.markdown-body ol ol, .markdown-body ol ul, .markdown-body ul ol, .markdown-body ul ul {
    margin-top: 3px
}

.markdown-body ol li {
    padding-left: 6px
}

.markdown-body .contains-task-list {
    padding-left: 0
}

.markdown-body .task-list-item {
    list-style: none
}

@media (max-width: 720px) {
    .markdown-body h1 {
        font-size: 24px
    }

    .markdown-body h2 {
        font-size: 20px
    }

    .markdown-body h3 {
        font-size: 18px
    }
}
    </style>
</head>
<body>
<div class="markdown-body">
    <p>在第七节的内容中，我们已经分析过 <code>依赖预构建</code>的意义以及使用，对于其底层的实现并没有作过多的介绍。而在 Vite 依赖预构建的底层实现中，大量地使用到了 Esbuild 这款构建工具，实现了比较复杂的 Esbuild 插件，同时也应用了诸多 Esbuild 使用技巧。相信在理解这部分的源码之后，你将会对 Vite 预构建以及 Esbuild 本身有更加深入的认识。</p>
<p>接下来，我就来带你揭开 <code>Vite 预构建</code>神秘的面纱，从核心流程到依赖扫描、依赖打包的具体实现，带你彻底理解预构建背后的技术，学习 Vite 是如何灵活运用 Esbuild，将 Esbuild 这个打包工具<code>玩出花来</code>的。</p>
<h2>预构建核心流程</h2>
<p>关于预构建所有的实现代码都在<code>optimizeDeps</code>函数当中，也就是在仓库源码的 <a href="https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/optimizer/index.ts" target="_blank" rel="nofollow noopener noreferrer">packages/vite/src/node/optimizer/index.ts</a> 文件中，你可以对照着来学习。</p>
<h3>缓存判断</h3>
<p>首先是预构建缓存的判断。Vite 在每次预构建之后都将一些关键信息写入到了<code>_metadata.json</code>文件中，第二次启动项目时会通过这个文件中的 hash 值来进行缓存的判断，如果命中缓存则不会进行后续的预构建流程，代码如下所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// _metadata.json 文件所在的路径</span>
<span class="hljs-keyword">const</span> dataPath = path.<span class="hljs-title function_">join</span>(cacheDir, <span class="hljs-string">"_metadata.json"</span>);
<span class="hljs-comment">// 根据当前的配置计算出哈希值</span>
<span class="hljs-keyword">const</span> mainHash = <span class="hljs-title function_">getDepHash</span>(root, config);
<span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DepOptimizationMetadata</span> = {
  <span class="hljs-attr">hash</span>: mainHash,
  <span class="hljs-attr">browserHash</span>: mainHash,
  <span class="hljs-attr">optimized</span>: {},
};
<span class="hljs-comment">// 默认走到里面的逻辑</span>
<span class="hljs-keyword">if</span> (!force) {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">prevData</span>: <span class="hljs-title class_">DepOptimizationMetadata</span> | <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 读取元数据</span>
    prevData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(dataPath, <span class="hljs-string">"utf-8"</span>));
  } <span class="hljs-keyword">catch</span> (e) {}
  <span class="hljs-comment">// 当前计算出的哈希值与 _metadata.json 中记录的哈希值一致，表示命中缓存，不用预构建</span>
  <span class="hljs-keyword">if</span> (prevData &#x26;&#x26; prevData.<span class="hljs-property">hash</span> === data.<span class="hljs-property">hash</span>) {
    <span class="hljs-title function_">log</span>(<span class="hljs-string">"Hash is consistent. Skipping. Use --force to override."</span>);
    <span class="hljs-keyword">return</span> prevData;
  }
}
</code></pre>
<p>值得注意的是哈希计算的策略，即决定哪些配置和文件有可能影响预构建的结果，然后根据这些信息来生成哈希值。这部分逻辑集中在<code>getHash</code>函数中，我把关键信息放到了注释中:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> lockfileFormats = [<span class="hljs-string">"package-lock.json"</span>, <span class="hljs-string">"yarn.lock"</span>, <span class="hljs-string">"pnpm-lock.yaml"</span>];
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepHash</span>(<span class="hljs-params">root: <span class="hljs-built_in">string</span>, config: ResolvedConfig</span>): <span class="hljs-built_in">string</span> {
  <span class="hljs-comment">// 获取 lock 文件内容</span>
  <span class="hljs-keyword">let</span> content = <span class="hljs-title function_">lookupFile</span>(root, lockfileFormats) || <span class="hljs-string">""</span>;
  <span class="hljs-comment">// 除了 lock 文件外，还需要考虑下面的一些配置信息</span>
  content += <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(
    {
      <span class="hljs-comment">// 开发/生产环境</span>
      <span class="hljs-attr">mode</span>: config.<span class="hljs-property">mode</span>,
      <span class="hljs-comment">// 项目根路径</span>
      <span class="hljs-attr">root</span>: config.<span class="hljs-property">root</span>,
      <span class="hljs-comment">// 路径解析配置</span>
      <span class="hljs-attr">resolve</span>: config.<span class="hljs-property">resolve</span>,
      <span class="hljs-comment">// 自定义资源类型</span>
      <span class="hljs-attr">assetsInclude</span>: config.<span class="hljs-property">assetsInclude</span>,
      <span class="hljs-comment">// 插件</span>
      <span class="hljs-attr">plugins</span>: config.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =></span> p.<span class="hljs-property">name</span>),
      <span class="hljs-comment">// 预构建配置</span>
      <span class="hljs-attr">optimizeDeps</span>: {
        <span class="hljs-attr">include</span>: config.<span class="hljs-property">optimizeDeps</span>?.<span class="hljs-property">include</span>,
        <span class="hljs-attr">exclude</span>: config.<span class="hljs-property">optimizeDeps</span>?.<span class="hljs-property">exclude</span>,
      },
    },
    <span class="hljs-comment">// 特殊处理函数和正则类型</span>
    <span class="hljs-function">(<span class="hljs-params">_, value</span>) =></span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"function"</span> || value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) {
        <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">toString</span>();
      }
      <span class="hljs-keyword">return</span> value;
    }
  );
  <span class="hljs-comment">// 最后调用 crypto 库中的 createHash 方法生成哈希</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createHash</span>(<span class="hljs-string">"sha256"</span>).<span class="hljs-title function_">update</span>(content).<span class="hljs-title function_">digest</span>(<span class="hljs-string">"hex"</span>).<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>);
}
</code></pre>
<h3>依赖扫描</h3>
<p>如果没有命中缓存，则会正式地进入依赖预构建阶段。不过 Vite 不会直接进行依赖的预构建，而是在之前探测一下项目中存在哪些依赖，收集依赖列表，也就是进行<code>依赖扫描</code>的过程。这个过程是必须的，因为 Esbuild 需要知道我们到底要打包哪些第三方依赖。关键代码如下:</p>
<pre><code class="hljs language-ts">({ deps, missing } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">scanImports</span>(config));
</code></pre>
<p>在<code>scanImports</code>方法内部主要会调用 Esbuild 提供的 <code>build</code> 方法:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">deps</span>: <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>> = {};
<span class="hljs-comment">// 扫描用到的 Esbuild 插件</span>
<span class="hljs-keyword">const</span> plugin = <span class="hljs-title function_">esbuildScanPlugin</span>(config, container, deps, missing, entries);
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
  <span class="hljs-comment">// 应用项目入口</span>
  entries.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =></span>
    <span class="hljs-title function_">build</span>({
      <span class="hljs-attr">absWorkingDir</span>: process.<span class="hljs-title function_">cwd</span>(),
      <span class="hljs-comment">// 注意这个参数</span>
      <span class="hljs-attr">write</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">entryPoints</span>: [entry],
      <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">format</span>: <span class="hljs-string">"esm"</span>,
      <span class="hljs-attr">logLevel</span>: <span class="hljs-string">"error"</span>,
      <span class="hljs-attr">plugins</span>: [...plugins, plugin],
      ...esbuildOptions,
    })
  )
);
</code></pre>
<p>值得注意的是，其中传入的<code>write</code>参数被设为 false，表示产物不用写入磁盘，这就大大节省了磁盘 I/O 的时间了，也是<code>依赖扫描</code>为什么往往比<code>依赖打包</code>快很多的原因之一。</p>
<p>接下来会输出预打包信息:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">if</span> (!asCommand) {
  <span class="hljs-keyword">if</span> (!newDeps) {
    logger.<span class="hljs-title function_">info</span>(
      chalk.<span class="hljs-title function_">greenBright</span>(<span class="hljs-string">`Pre-bundling dependencies:\n  <span class="hljs-subst">${depsString}</span>`</span>)
    );
    logger.<span class="hljs-title function_">info</span>(
      <span class="hljs-string">`(this will be run only when your dependencies or config have changed)`</span>
    );
  }
} <span class="hljs-keyword">else</span> {
  logger.<span class="hljs-title function_">info</span>(chalk.<span class="hljs-title function_">greenBright</span>(<span class="hljs-string">`Optimizing dependencies:\n  <span class="hljs-subst">${depsString}</span>`</span>));
}
</code></pre>
<p>这时候你可以明白，为什么第一次启动时会输出预构建相关的 log 信息了，其实这些信息都是通过<code>依赖扫描</code>阶段来搜集的，而此时还并未开始真正的依赖打包过程。</p>
<p>可能你会有疑问，为什么对项目入口打包一次就收集到所有依赖信息了呢？大家可以注意到<code>esbuildScanPlugin</code>这个函数创建 <code>scan 插件</code>的时候就接收到了<code>deps</code>对象作为入参，这个对象的作用不可小觑，在 <code>scan 插件</code>里面就是解析各种 import 语句，最终通过它来记录依赖信息。由于解析的过程比较复杂，我们放到下一个部分具体讲解，这里你只需要知道核心的流程即可。</p>
<h3>依赖打包</h3>
<p>收集完依赖之后，就正式地进入到<code>依赖打包</code>的阶段了。这里也调用 Esbuild 进行打包并写入产物到磁盘中，关键代码如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">build</span>({
  <span class="hljs-attr">absWorkingDir</span>: process.<span class="hljs-title function_">cwd</span>(),
  <span class="hljs-comment">// 所有依赖的 id 数组，在插件中会转换为真实的路径</span>
  <span class="hljs-attr">entryPoints</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(flatIdDeps),
  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">format</span>: <span class="hljs-string">"esm"</span>,
  <span class="hljs-attr">target</span>: config.<span class="hljs-property">build</span>.<span class="hljs-property">target</span> || <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">external</span>: config.<span class="hljs-property">optimizeDeps</span>?.<span class="hljs-property">exclude</span>,
  <span class="hljs-attr">logLevel</span>: <span class="hljs-string">"error"</span>,
  <span class="hljs-attr">splitting</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">outdir</span>: cacheDir,
  <span class="hljs-attr">ignoreAnnotations</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">metafile</span>: <span class="hljs-literal">true</span>,
  define,
  <span class="hljs-attr">plugins</span>: [
    ...plugins,
    <span class="hljs-comment">// 预构建专用的插件</span>
    <span class="hljs-title function_">esbuildDepPlugin</span>(flatIdDeps, flatIdToExports, config, ssr),
  ],
  ...esbuildOptions,
});
<span class="hljs-comment">// 打包元信息，后续会根据这份信息生成 _metadata.json</span>
<span class="hljs-keyword">const</span> meta = result.<span class="hljs-property">metafile</span>!;
</code></pre>
<h3>元信息写入磁盘</h3>
<p>在打包过程完成之后，Vite 会拿到 Esbuild 构建的元信息，也就是上面代码中的<code>meta</code>对象，然后将元信息保存到<code>_metadata.json</code>文件中:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DepOptimizationMetadata</span> = {
  <span class="hljs-attr">hash</span>: mainHash,
  <span class="hljs-attr">browserHash</span>: mainHash,
  <span class="hljs-attr">optimized</span>: {},
};
<span class="hljs-comment">// 省略中间的代码</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">in</span> deps) {
  <span class="hljs-keyword">const</span> entry = deps[id];
  data.<span class="hljs-property">optimized</span>[id] = {
    <span class="hljs-attr">file</span>: <span class="hljs-title function_">normalizePath</span>(path.<span class="hljs-title function_">resolve</span>(cacheDir, <span class="hljs-title function_">flattenId</span>(id) + <span class="hljs-string">".js"</span>)),
    <span class="hljs-attr">src</span>: entry,
    <span class="hljs-comment">// 判断是否需要转换成 ESM 格式，后面会介绍</span>
    <span class="hljs-attr">needsInterop</span>: <span class="hljs-title function_">needsInterop</span>(
      id,
      idToExports[id],
      meta.<span class="hljs-property">outputs</span>,
      cacheDirOutputPath
    ),
  };
}
<span class="hljs-comment">// 元信息写磁盘</span>
<span class="hljs-title function_">writeFile</span>(dataPath, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));
</code></pre>
<p>到这里，预构建的核心流程就梳理完了，可以看到总体的流程上面并不复杂，但实际上为了方便你理解，在<code>依赖扫描</code>和<code>依赖打包</code>这两个部分中，我省略了很多的细节，每个细节代表了各种复杂的处理场景，因此，在下面的篇幅中，我们就来好好地剖析一下这两部分的应用场景和实现细节。</p>
<h2>依赖扫描详细分析</h2>
<h3>1. 如何获取入口</h3>
<p>现在让我们把目光聚焦在<code>scanImports</code>的实现上。大家可以先想一想，在进行依赖扫描之前，需要做的第一件事是什么？很显然，是找到入口文件。但入口文件可能存在于多个配置当中，比如<code>optimizeDeps.entries</code>和<code>build.rollupOptions.input</code>，同时需要考虑数组和对象的情况；也可能用户没有配置，需要自动探测入口文件。那么，在<code>scanImports</code>是如何做到的呢？</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> explicitEntryPatterns = config.<span class="hljs-property">optimizeDeps</span>.<span class="hljs-property">entries</span>;
<span class="hljs-keyword">const</span> buildInput = config.<span class="hljs-property">build</span>.<span class="hljs-property">rollupOptions</span>?.<span class="hljs-property">input</span>;
<span class="hljs-keyword">if</span> (explicitEntryPatterns) {
  <span class="hljs-comment">// 先从 optimizeDeps.entries 寻找入口，支持 glob 语法</span>
  entries = <span class="hljs-keyword">await</span> <span class="hljs-title function_">globEntries</span>(explicitEntryPatterns, config);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buildInput) {
  <span class="hljs-comment">// 其次从 build.rollupOptions.input 配置中寻找，注意需要考虑数组和对象的情况</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolvePath</span> = (<span class="hljs-params">p: <span class="hljs-built_in">string</span></span>) => path.<span class="hljs-title function_">resolve</span>(config.<span class="hljs-property">root</span>, p);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> buildInput === <span class="hljs-string">"string"</span>) {
    entries = [<span class="hljs-title function_">resolvePath</span>(buildInput)];
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(buildInput)) {
    entries = buildInput.<span class="hljs-title function_">map</span>(resolvePath);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(buildInput)) {
    entries = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(buildInput).<span class="hljs-title function_">map</span>(resolvePath);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"invalid rollupOptions.input value."</span>);
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 兜底逻辑，如果用户没有进行上述配置，则自动从根目录开始寻找</span>
  entries = <span class="hljs-keyword">await</span> <span class="hljs-title function_">globEntries</span>(<span class="hljs-string">"**/*.html"</span>, config);
}
</code></pre>
<p>其中 <code>globEntries</code> 方法即通过 <code>fast-glob</code> 库来从项目根目录扫描文件。</p>
<p>接下来我们还需要考虑入口文件的类型，一般情况下入口需要是<code>js/ts</code>文件，但实际上像 html、vue 单文件组件这种类型我们也是需要支持的，因为在这些文件中仍然可以包含 script 标签的内容，从而让我们搜集到依赖信息。</p>
<p>在源码当中，同时对 <code>html</code>、<code>vue</code>、<code>svelte</code>、<code>astro</code>(一种新兴的类 html 语法)四种后缀的入口文件进行了解析，当然，具体的解析过程在<code>依赖扫描</code>阶段的 Esbuild 插件中得以实现，接着就让我们在插件的实现中一探究竟。</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> htmlTypesRE = <span class="hljs-regexp">/.(html|vue|svelte|astro)$/</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">esbuildScanPlugin</span>(<span class="hljs-params"><span class="hljs-comment">/* 一些入参 */</span></span>): <span class="hljs-title class_">Plugin</span> {
  <span class="hljs-comment">// 初始化一些变量</span>
  <span class="hljs-comment">// 返回一个 Esbuild 插件</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"vite:dep-scan"</span>,
    <span class="hljs-title function_">setup</span>(<span class="hljs-params">build</span>) {
      <span class="hljs-comment">// 标记「类 HTML」文件的 namespace</span>
      build.<span class="hljs-title function_">onResolve</span>({ <span class="hljs-attr">filter</span>: htmlTypesRE }, <span class="hljs-keyword">async</span> ({ path, importer }) => {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">path</span>: <span class="hljs-keyword">await</span> <span class="hljs-title function_">resolve</span>(path, importer),
          <span class="hljs-attr">namespace</span>: <span class="hljs-string">"html"</span>,
        };
      });

      build.<span class="hljs-title function_">onLoad</span>(
        { <span class="hljs-attr">filter</span>: htmlTypesRE, <span class="hljs-attr">namespace</span>: <span class="hljs-string">"html"</span> },
        <span class="hljs-keyword">async</span> ({ path }) => {
          <span class="hljs-comment">// 解析「类 HTML」文件</span>
        }
      );
    },
  };
}
</code></pre>
<p>这里来我们以<code>html</code>文件的解析为例来讲解，原理如下图所示:</p>
<p><img src="img\c842afb2-ae61-11ed-81f2-342eb7027b95.jpg" alt=""></p>
<p>在插件中会扫描出所有带有 <code>type=module</code> 的 script 标签，对于含有 src 的 <code>script</code> 改写为一个 import 语句，对于含有具体内容的 script，则抽离出其中的脚本内容，最后将所有的 script 内容拼接成一段 js 代码。接下来我们来看具体的代码，其中会以上图中的<code>html</code>为示例来拆解中间过程:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> scriptModuleRE =
  <span class="hljs-regexp">/(&#x3C;script\b[^>]*type\s*=\s*(?: module |'module')[^>]*>)(.*?)&#x3C;/</span>script>/gims
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> scriptRE = <span class="hljs-regexp">/(&#x3C;script\b(?:\s[^>]*>|>))(.*?)&#x3C;/</span>script>/gims
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> commentRE = <span class="hljs-regexp">/&#x3C;!--(.|[\r\n])*?-->/</span>
<span class="hljs-keyword">const</span> srcRE = <span class="hljs-regexp">/\bsrc\s*=\s*(?: ([^ ]+) |'([^']+)'|([^\s' >]+))/im</span>
<span class="hljs-keyword">const</span> typeRE = <span class="hljs-regexp">/\btype\s*=\s*(?: ([^ ]+) |'([^']+)'|([^\s' >]+))/im</span>
<span class="hljs-keyword">const</span> langRE = <span class="hljs-regexp">/\blang\s*=\s*(?: ([^ ]+) |'([^']+)'|([^\s' >]+))/im</span>
<span class="hljs-comment">// scan 插件 setup 方法内部实现</span>
build.<span class="hljs-title function_">onLoad</span>(
  { <span class="hljs-attr">filter</span>: htmlTypesRE, <span class="hljs-attr">namespace</span>: <span class="hljs-string">'html'</span> },
  <span class="hljs-keyword">async</span> ({ path }) => {
    <span class="hljs-keyword">let</span> raw = fs.<span class="hljs-title function_">readFileSync</span>(path, <span class="hljs-string">'utf-8'</span>)
    <span class="hljs-comment">// 去掉注释内容，防止干扰解析过程</span>
    raw = raw.<span class="hljs-title function_">replace</span>(commentRE, <span class="hljs-string">'&#x3C;!---->'</span>)
    <span class="hljs-keyword">const</span> isHtml = path.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.html'</span>)
    <span class="hljs-comment">// HTML 情况下会寻找 type 为 module 的 script</span>
    <span class="hljs-comment">// 正则：/(&#x3C;script\b[^>]*type\s*=\s*(?: module |'module')[^>]*>)(.*?)&#x3C;/script>/gims</span>
    <span class="hljs-keyword">const</span> regex = isHtml ? scriptModuleRE : scriptRE
    regex.<span class="hljs-property">lastIndex</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> js = <span class="hljs-string">''</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">loader</span>: <span class="hljs-title class_">Loader</span> = <span class="hljs-string">'js'</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">match</span>: <span class="hljs-title class_">RegExpExecArray</span> | <span class="hljs-literal">null</span>
    <span class="hljs-comment">// 正式开始解析</span>
    <span class="hljs-keyword">while</span> ((match = regex.<span class="hljs-title function_">exec</span>(raw))) {
      <span class="hljs-comment">// 第一次: openTag 为 &#x3C;script type= module  src= /src/main.ts >, 无 content</span>
      <span class="hljs-comment">// 第二次: openTag 为 &#x3C;script type= module >，有 content</span>
      <span class="hljs-keyword">const</span> [, openTag, content] = match
      <span class="hljs-keyword">const</span> typeMatch = openTag.<span class="hljs-title function_">match</span>(typeRE)
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> =
        typeMatch &#x26;&#x26; (typeMatch[<span class="hljs-number">1</span>] || typeMatch[<span class="hljs-number">2</span>] || typeMatch[<span class="hljs-number">3</span>])
      <span class="hljs-keyword">const</span> langMatch = openTag.<span class="hljs-title function_">match</span>(langRE)
      <span class="hljs-keyword">const</span> lang =
        langMatch &#x26;&#x26; (langMatch[<span class="hljs-number">1</span>] || langMatch[<span class="hljs-number">2</span>] || langMatch[<span class="hljs-number">3</span>])
      <span class="hljs-keyword">if</span> (lang === <span class="hljs-string">'ts'</span> || lang === <span class="hljs-string">'tsx'</span> || lang === <span class="hljs-string">'jsx'</span>) {
        <span class="hljs-comment">// 指定 esbuild 的 loader</span>
        loader = lang
      }
      <span class="hljs-keyword">const</span> srcMatch = openTag.<span class="hljs-title function_">match</span>(srcRE)
      <span class="hljs-comment">// 根据有无 src 属性来进行不同的处理</span>
      <span class="hljs-keyword">if</span> (srcMatch) {
        <span class="hljs-keyword">const</span> src = srcMatch[<span class="hljs-number">1</span>] || srcMatch[<span class="hljs-number">2</span>] || srcMatch[<span class="hljs-number">3</span>]
        js += <span class="hljs-string">`import <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(src)}</span>\n`</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (content.<span class="hljs-title function_">trim</span>()) {
        js += content + <span class="hljs-string">'\n'</span>
      }
  }
  <span class="hljs-keyword">return</span> {
    loader,
    <span class="hljs-attr">contents</span>: js
  }
)
</code></pre>
<p>这里对源码做了一定的精简，省略了 <code>vue</code>/<code>svelte</code> 以及 <code>import.meta.glob</code> 语法的处理，但不影响整体的实现思路，这里主要是让你了解即使是<code>html</code>或者类似这种类型的文件，也是能作为 Esbuild 的预构建入口来进行解析的。</p>
<h3>2. 如何记录依赖？</h3>
<p>入口的问题解决了，接下来还有一个问题: 如何在 Esbuild 编译的时候记录依赖呢？</p>
<p>Vite 中会把 <code>bare import</code>的路径当做依赖路径，关于<code>bare import</code>，你可以理解为直接引入一个包名，比如下面这样:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
</code></pre>
<p>而以<code>.</code>开头的相对路径或者以<code>/</code>开头的绝对路径都不能算<code>bare import</code>:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 以下都不是 bare import</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"../node_modules/react/index.js"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"/User/sanyuan/vite-project/node_modules/react/index.js"</span>;
</code></pre>
<p>对于解析 <code>bare import</code>、记录依赖的逻辑依然实现在 scan 插件当中:</p>
<pre><code class="hljs language-ts">build.<span class="hljs-title function_">onResolve</span>(
  {
    <span class="hljs-comment">// avoid matching windows volume</span>
    <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/^[\w@][^:]/</span>,
  },
  <span class="hljs-keyword">async</span> ({ <span class="hljs-attr">path</span>: id, importer }) => {
    <span class="hljs-comment">// 如果在 optimizeDeps.exclude 列表或者已经记录过了，则将其 externalize (排除)，直接 return</span>

    <span class="hljs-comment">// 接下来解析路径，内部调用各个插件的 resolveId 方法进行解析</span>
    <span class="hljs-keyword">const</span> resolved = <span class="hljs-keyword">await</span> <span class="hljs-title function_">resolve</span>(id, importer);
    <span class="hljs-keyword">if</span> (resolved) {
      <span class="hljs-comment">// 判断是否应该 externalize，下个部分详细拆解</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldExternalizeDep</span>(resolved, id)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">externalUnlessEntry</span>({ <span class="hljs-attr">path</span>: id });
      }

      <span class="hljs-keyword">if</span> (resolved.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"node_modules"</span>) || include?.<span class="hljs-title function_">includes</span>(id)) {
        <span class="hljs-comment">// 如果 resolved 为 js 或 ts 文件</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">OPTIMIZABLE_ENTRY_RE</span>.<span class="hljs-title function_">test</span>(resolved)) {
          <span class="hljs-comment">// 注意了! 现在将其正式地记录在依赖表中</span>
          depImports[id] = resolved;
        }
        <span class="hljs-comment">// 进行 externalize，因为这里只用扫描出依赖即可，不需要进行打包，具体实现后面的部分会讲到</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">externalUnlessEntry</span>({ <span class="hljs-attr">path</span>: id });
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// resolved 为 「类 html」 文件，则标记上 'html' 的 namespace</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">namespace</span> = htmlTypesRE.test(resolved) ? "html" : undefined;
        // linked package, keep crawling
        return {
          <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(resolved),
          <span class="hljs-keyword">namespace</span>,
        };
      }
    } else {
      <span class="hljs-comment">// 没有解析到路径，记录到 missing 表中，后续会检测这张表，显示相关路径未找到的报错</span>
      missing[id] = <span class="hljs-title function_">normalizePath</span>(importer);
    }
  }
);
</code></pre>
<p>顺便说一句，其中调用到了<code>resolve</code>，也就是路径解析的逻辑，这里面实际上会调用各个插件的 resolveId 方法来进行路径的解析，代码如下所示:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id: <span class="hljs-built_in">string</span>, importer?: <span class="hljs-built_in">string</span></span>) => {
  <span class="hljs-comment">// 通过 seen 对象进行路径缓存</span>
  <span class="hljs-keyword">const</span> key = id + (importer &#x26;&#x26; path.<span class="hljs-title function_">dirname</span>(importer));
  <span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(key)) {
    <span class="hljs-keyword">return</span> seen.<span class="hljs-title function_">get</span>(key);
  }
  <span class="hljs-comment">// 调用插件容器的 resolveId</span>
  <span class="hljs-comment">// 关于插件容器下一节会详细介绍，这里你直接理解为调用各个插件的 resolveId 方法解析路径即可</span>
  <span class="hljs-keyword">const</span> resolved = <span class="hljs-keyword">await</span> container.<span class="hljs-title function_">resolveId</span>(
    id,
    importer &#x26;&#x26; <span class="hljs-title function_">normalizePath</span>(importer)
  );
  <span class="hljs-keyword">const</span> res = resolved?.<span class="hljs-property">id</span>;
  seen.<span class="hljs-title function_">set</span>(key, res);
  <span class="hljs-keyword">return</span> res;
};
</code></pre>
<h3>3. external 的规则如何制定？</h3>
<p>上面我们分析了在 Esbuild 插件中如何针对 <code>bare import</code> 记录依赖，那么在记录的过程中还有一件非常重要的事情，就是决定哪些路径应该被排除，不应该被记录或者不应该被 Esbuild 来解析。这就是 <code>external 规则</code>的概念。</p>
<p>在这里，我把需要 external 的路径分为两类: <strong>资源型</strong>和<strong>模块型</strong>。</p>
<p>首先，对于资源型的路径，一般是直接排除，在插件中的处理方式如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// data url，直接标记 external: true，不让 esbuild 继续处理</span>
build.<span class="hljs-title function_">onResolve</span>({ <span class="hljs-attr">filter</span>: dataUrlRE }, <span class="hljs-function">(<span class="hljs-params">{ path }</span>) =></span> ({
  path,
  <span class="hljs-attr">external</span>: <span class="hljs-literal">true</span>,
}));
<span class="hljs-comment">// 加了 ?worker 或者 ?raw 这种 query 的资源路径，直接 external</span>
build.<span class="hljs-title function_">onResolve</span>({ <span class="hljs-attr">filter</span>: <span class="hljs-variable constant_">SPECIAL_QUERY_RE</span> }, <span class="hljs-function">(<span class="hljs-params">{ path }</span>) =></span> ({
  path,
  <span class="hljs-attr">external</span>: <span class="hljs-literal">true</span>,
}));
<span class="hljs-comment">// css &#x26; json</span>
build.<span class="hljs-title function_">onResolve</span>(
  {
    <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/.(css|less|sass|scss|styl|stylus|pcss|postcss|json)$/</span>,
  },
  <span class="hljs-comment">// 非 entry 则直接标记 external</span>
  externalUnlessEntry
);
<span class="hljs-comment">// Vite 内置的一些资源类型，比如 .png、.wasm 等等</span>
build.<span class="hljs-title function_">onResolve</span>(
  {
    <span class="hljs-attr">filter</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`\.(<span class="hljs-subst">${KNOWN_ASSET_TYPES.join(<span class="hljs-string">"|"</span>)}</span>)$`</span>),
  },
  <span class="hljs-comment">// 非 entry 则直接标记 external</span>
  externalUnlessEntry
);
</code></pre>
<p>其中<code>externalUnlessEntry</code>的实现也很简单:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">externalUnlessEntry</span> = (<span class="hljs-params">{ path }: { path: <span class="hljs-built_in">string</span> }</span>) => ({
  path,
  <span class="hljs-comment">// 非 entry 则标记 external</span>
  <span class="hljs-attr">external</span>: !entries.<span class="hljs-title function_">includes</span>(path),
});
</code></pre>
<p>其次，对于模块型的路径，也就是当我们通过 resolve 函数解析出了一个 JS 模块的路径，如何判断是否应该被 externalize 呢？这部分实现主要在<code>shouldExternalizeDep</code> 函数中，之前在分析<code>bare import</code>埋了个伏笔，现在让我们看看具体的实现规则:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldExternalizeDep</span>(<span class="hljs-params">
  resolvedId: <span class="hljs-built_in">string</span>,
  rawId: <span class="hljs-built_in">string</span>
</span>): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-comment">// 解析之后不是一个绝对路径，不在 esbuild 中进行加载</span>
  <span class="hljs-keyword">if</span> (!path.<span class="hljs-title function_">isAbsolute</span>(resolvedId)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-comment">// 1. import 路径本身就是一个绝对路径</span>
  <span class="hljs-comment">// 2. 虚拟模块(Rollup 插件中约定虚拟模块以`\0`开头)</span>
  <span class="hljs-comment">// 都不在 esbuild 中进行加载</span>
  <span class="hljs-keyword">if</span> (resolvedId === rawId || resolvedId.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"\0"</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-comment">// 不是 JS 或者 类 HTML 文件，不在 esbuild 中进行加载</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-variable constant_">JS_TYPES_RE</span>.<span class="hljs-title function_">test</span>(resolvedId) &#x26;&#x26; !htmlTypesRE.<span class="hljs-title function_">test</span>(resolvedId)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<h2>依赖打包详细分析</h2>
<h3>1. 如何达到扁平化的产物文件结构</h3>
<p>一般情况下，esbuild 会输出嵌套的产物目录结构，比如对 vue 来说，其产物在<code>dist/vue.runtime.esm-bundler.js</code>中，那么经过 esbuild 正常打包之后，预构建的产物目录如下:</p>
<pre><code class="hljs language-ts">node_modules/.<span class="hljs-property">vite</span>
├── _metadata.<span class="hljs-property">json</span>
├── vue
│   └── dist
│       └── vue.<span class="hljs-property">runtime</span>.<span class="hljs-property">esm</span>-bundler.<span class="hljs-property">js</span>
</code></pre>
<p>由于各个第三方包的产物目录结构不一致，这种深层次的嵌套目录对于 Vite 路径解析来说，其实是增加了不少的麻烦的，带来了一些不可控的因素。为了解决嵌套目录带来的问题，Vite 做了两件事情来达到扁平化的预构建产物输出:</p>
<ol>
<li>嵌套路径扁平化，<code>/</code>被换成下划线，如 <code>react/jsx-dev-runtime</code>，被重写为<code>react_jsx-dev-runtime</code>；</li>
</ol>

<ol start="2">
<li>用虚拟模块来代替真实模块，作为预打包的入口，具体的实现后面会详细介绍。</li>
</ol>
<p>回到<code>optimizeDeps</code>函数中，其中在进行完依赖扫描的步骤后，就会执行路径的扁平化操作:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">flatIdDeps</span>: <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>> = {};
<span class="hljs-keyword">const</span> <span class="hljs-attr">idToExports</span>: <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">ExportsData</span>> = {};
<span class="hljs-keyword">const</span> <span class="hljs-attr">flatIdToExports</span>: <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">ExportsData</span>> = {};
<span class="hljs-comment">// deps 即为扫描后的依赖表</span>
<span class="hljs-comment">// 形如: {</span>
<span class="hljs-comment">//    react :  /Users/sanyuan/vite-project/react/index.js  }</span>
<span class="hljs-comment">//    react/jsx-dev-runtime :  /Users/sanyuan/vite-project/react/jsx-dev-runtime.js</span>
<span class="hljs-comment">// }</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">in</span> deps) {
  <span class="hljs-comment">// 扁平化路径，`react/jsx-dev-runtime`，被重写为`react_jsx-dev-runtime`；</span>
  <span class="hljs-keyword">const</span> flatId = <span class="hljs-title function_">flattenId</span>(id);
  <span class="hljs-comment">// 填入 flatIdDeps 表，记录 flatId -> 真实路径的映射关系</span>
  <span class="hljs-keyword">const</span> filePath = (flatIdDeps[flatId] = deps[id]);
  <span class="hljs-keyword">const</span> entryContent = fs.<span class="hljs-title function_">readFileSync</span>(filePath, <span class="hljs-string">"utf-8"</span>);
  <span class="hljs-comment">// 后续代码省略</span>
}
</code></pre>
<p>对于虚拟模块的处理，大家可以把目光放到 <code>esbuildDepPlugin</code> 函数上面，它的逻辑大致如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">esbuildDepPlugin</span>(<span class="hljs-params"><span class="hljs-comment">/* 一些传参 */</span></span>) {
  <span class="hljs-comment">// 定义路径解析的方法</span>

  <span class="hljs-comment">// 返回 Esbuild 插件</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite:dep-pre-bundle'</span>,
    <span class="hljs-title function_">set</span>(<span class="hljs-params">build</span>) {
      <span class="hljs-comment">// bare import 的路径</span>
      build.<span class="hljs-title function_">onResolve</span>(
        { <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/^[\w@][^:]/</span> },
        <span class="hljs-keyword">async</span> ({ <span class="hljs-attr">path</span>: id, importer, kind }) => {
          <span class="hljs-comment">// 判断是否为入口模块，如果是，则标记上`dep`的 namespace，成为一个虚拟模块</span>
        }
    }

    build.<span class="hljs-title function_">onLoad</span>({ <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/.*/</span>, <span class="hljs-attr">namespace</span>: <span class="hljs-string">'dep'</span> }, <span class="hljs-function">(<span class="hljs-params">{ path: id }</span>) =></span> {
      <span class="hljs-comment">// 加载虚拟模块</span>
    }
  }
}
</code></pre>
<p>如此一来，Esbuild 会将虚拟模块作为入口来进行打包，最后的产物目录会变成下面的扁平结构:</p>
<pre><code class="hljs language-ts">node_modules/.<span class="hljs-property">vite</span>
├── _metadata.<span class="hljs-property">json</span>
├── vue.<span class="hljs-property">js</span>
├── react.<span class="hljs-property">js</span>
├── react_jsx-dev-runtime.<span class="hljs-property">js</span>
</code></pre>
<blockquote>
<p>注：<strong>虚拟模块加载部分的代码</strong>在 Vite 3.0 中已被移除，原因是 Esbuild 输出扁平化产物路径已不再需要使用虚拟模块，PR 地址: <a href="https://github.com/vitejs/vite/pull/10427" target="_blank" rel="nofollow noopener noreferrer">https://github.com/vitejs/vite/pull/10427</a> 如下部分的小册内容你可以进行选读。</p>
</blockquote>
<h3>2. 代理模块加载</h3>
<p>虚拟模块代替了真实模块作为打包入口，因此也可以理解为<code>代理模块</code>，后面也统一称之为<code>代理模块</code>。我们首先来分析一下代理模块究竟是如何被加载出来的，换句话说，它到底了包含了哪些内容。</p>
<p>拿<code>import React from "react"</code>来举例，Vite 会把<code>react</code>标记为 <code>namespace</code> 为 <code>dep</code> 的虚拟模块，然后控制 Esbuild 的加载流程，对于真实模块的内容进行重新导出。</p>
<p>那么第一步就是确定真实模块的路径:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 真实模块所在的路径，拿 react 来说，即`node_modules/react/index.js`</span>
<span class="hljs-keyword">const</span> entryFile = qualified[id];
<span class="hljs-comment">// 确定相对路径</span>
<span class="hljs-keyword">let</span> relativePath = <span class="hljs-title function_">normalizePath</span>(path.<span class="hljs-title function_">relative</span>(root, entryFile));
<span class="hljs-keyword">if</span> (
  !relativePath.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"./"</span>) &#x26;&#x26;
  !relativePath.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"../"</span>) &#x26;&#x26;
  relativePath !== <span class="hljs-string">"."</span>
) {
  relativePath = <span class="hljs-string">`./<span class="hljs-subst">${relativePath}</span>`</span>;
}
</code></pre>
<p>确定了路径之后，接下来就是对模块的内容进行重新导出。这里会分为几种情况:</p>
<ul>
<li>
<p>CommonJS 模块</p>
</li>
<li>
<p>ES 模块</p>
</li>
</ul>
<p>那么，如何来识别这两种模块规范呢？</p>
<p>我们可以暂时把目光转移到<code>optimizeDeps</code>中，实际上在进行真正的依赖打包之前，Vite 会读取各个依赖的入口文件，通过<code>es-module-lexer</code>这种工具来解析入口文件的内容。这里稍微解释一下<code>es-module-lexer</code>，这是一个在 Vite 被经常使用到的工具库，主要是为了解析 ES 导入导出的语法，大致用法如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { init, parse } <span class="hljs-keyword">from</span> <span class="hljs-string">"es-module-lexer"</span>;
<span class="hljs-comment">// 等待`es-module-lexer`初始化完成</span>
<span class="hljs-keyword">await</span> init;
<span class="hljs-keyword">const</span> sourceStr = <span class="hljs-string">`
  import moduleA from './a';
  export * from 'b';
  export const count = 1;
  export default count;
`</span>;
<span class="hljs-comment">// 开始解析</span>
<span class="hljs-keyword">const</span> exportsData = <span class="hljs-title function_">parse</span>(sourceStr);
<span class="hljs-comment">// 结果为一个数组，分别保存 import 和 export 的信息</span>
<span class="hljs-keyword">const</span> [imports, <span class="hljs-built_in">exports</span>] = exportsData;
<span class="hljs-comment">// 返回 `import module from './a'`</span>
sourceStr.<span class="hljs-title function_">substring</span>(imports[<span class="hljs-number">0</span>].<span class="hljs-property">ss</span>, imports[<span class="hljs-number">0</span>].<span class="hljs-property">se</span>);
<span class="hljs-comment">// 返回 ['count', 'default']</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>);
</code></pre>
<p>值得注意的是, <code>export * from</code> 导出语法会被记录在 <code>import</code> 信息中。</p>
<p>接下来我们来看看 <code>optimizeDeps</code> 中如何利用 <code>es-module-lexer</code>来解析入口文件的，实现代码如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { init, parse } <span class="hljs-keyword">from</span> <span class="hljs-string">"es-module-lexer"</span>;
<span class="hljs-comment">// 省略中间的代码</span>
<span class="hljs-keyword">await</span> init;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">in</span> deps) {
  <span class="hljs-comment">// 省略前面的路径扁平化逻辑</span>
  <span class="hljs-comment">// 读取入口内容</span>
  <span class="hljs-keyword">const</span> entryContent = fs.<span class="hljs-title function_">readFileSync</span>(filePath, <span class="hljs-string">"utf-8"</span>);
  <span class="hljs-keyword">try</span> {
    exportsData = <span class="hljs-title function_">parse</span>(entryContent) <span class="hljs-keyword">as</span> <span class="hljs-title class_">ExportsData</span>;
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-comment">// 省略对 jsx 的处理</span>
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { ss, se } <span class="hljs-keyword">of</span> exportsData[<span class="hljs-number">0</span>]) {
    <span class="hljs-keyword">const</span> exp = entryContent.<span class="hljs-title function_">slice</span>(ss, se);
    <span class="hljs-comment">// 标记存在 `export * from` 语法</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/export\s+*\s+from/</span>.<span class="hljs-title function_">test</span>(exp)) {
      exportsData.<span class="hljs-property">hasReExports</span> = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-comment">// 将 import 和 export 信息记录下来</span>
  idToExports[id] = exportsData;
  flatIdToExports[flatId] = exportsData;
}
</code></pre>
<p>OK，由于最后会有两张表记录下 ES 模块导入和导出的相关信息，而<code>flatIdToExports</code>表会作为入参传给 Esbuild 插件:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 第二个入参</span>
<span class="hljs-title function_">esbuildDepPlugin</span>(flatIdDeps, flatIdToExports, config, ssr);
</code></pre>
<p>如此，我们就能根据真实模块的路径获取到导入和导出的信息，通过这份信息来甄别 CommonJS 和 ES 两种模块规范。现在可以回到 Esbuild 打包插件中<strong>加载代理模块</strong>的代码:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">let</span> contents = <span class="hljs-string">""</span>;
<span class="hljs-comment">// 下面的 exportsData 即外部传入的模块导入导出相关的信息表</span>
<span class="hljs-comment">// 根据模块 id 拿到对应的导入导出信息</span>
<span class="hljs-keyword">const</span> data = exportsData[id];
<span class="hljs-keyword">const</span> [imports, <span class="hljs-built_in">exports</span>] = data;
<span class="hljs-keyword">if</span> (!imports.<span class="hljs-property">length</span> &#x26;&#x26; !<span class="hljs-built_in">exports</span>.<span class="hljs-property">length</span>) {
  <span class="hljs-comment">// 处理 CommonJS 模块</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 处理 ES  模块</span>
}
</code></pre>
<p>如果是 CommonJS 模块，则导出语句写成这种形式:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">let</span> contents = <span class="hljs-string">""</span>;
contents += <span class="hljs-string">`export default require( <span class="hljs-subst">${relativePath}</span> );`</span>;
</code></pre>
<p>如果是 ES 模块，则分<strong>默认导出</strong>和<strong>非默认导出</strong>这两种情况来处理:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 默认导出，即存在 export default 语法</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">exports</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"default"</span>)) {
  contents += <span class="hljs-string">`import d from  <span class="hljs-subst">${relativePath}</span> ;export default d;`</span>;
}
<span class="hljs-comment">// 非默认导出</span>
<span class="hljs-keyword">if</span> (
  <span class="hljs-comment">// 1. 存在 `export * from` 语法，前文分析过</span>
  data.<span class="hljs-property">hasReExports</span> ||
  <span class="hljs-comment">// 2. 多个导出内容</span>
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">length</span> > <span class="hljs-number">1</span> ||
  <span class="hljs-comment">// 3. 只有一个导出内容，但这个导出不是 export default</span>
  <span class="hljs-built_in">exports</span>[<span class="hljs-number">0</span>] !== <span class="hljs-string">"default"</span>
) {
  <span class="hljs-comment">// 凡是命中上述三种情况中的一种，则添加下面的重导出语句</span>
  contents += <span class="hljs-string">`\nexport * from  <span class="hljs-subst">${relativePath}</span> `</span>;
}
</code></pre>
<p>现在，我们组装好了 <code>代理模块</code> 的内容，接下来就可以放心地交给 Esbuild 加载了:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">let</span> ext = path.<span class="hljs-title function_">extname</span>(entryFile).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">if</span> (ext === <span class="hljs-string">"mjs"</span>) ext = <span class="hljs-string">"js"</span>;
<span class="hljs-keyword">return</span> {
  <span class="hljs-attr">loader</span>: ext <span class="hljs-keyword">as</span> <span class="hljs-title class_">Loader</span>,
  <span class="hljs-comment">// 虚拟模块内容</span>
  contents,
  <span class="hljs-attr">resolveDir</span>: root,
};
</code></pre>
<h3>3. 代理模块为什么要和真实模块分离？</h3>
<p>现在，相信你已经清楚了 Vite 是如何组装代理模块，以此作为 Esbuild 打包入口的，整体的思路就是先分析一遍模块真实入口文件的<code>import</code>和<code>export</code>语法，然后在代理模块中进行重导出。这里不妨回过头来思考一下: 为什么要对真实文件先做语法分析，然后重导出内容呢？</p>
<p>对此，大家不妨注意一下代码中的这段注释:</p>
<pre><code class="hljs language-ts"><span class="hljs-comment">// It is necessary to do the re-exporting to separate the virtual proxy</span>
<span class="hljs-comment">// module from the actual module since the actual module may get</span>
<span class="hljs-comment">// referenced via relative imports - if we don't separate the proxy and</span>
<span class="hljs-comment">// the actual module, esbuild will create duplicated copies of the same</span>
<span class="hljs-comment">// module!</span>
</code></pre>
<p>翻译过来即:</p>
<blockquote>
<p>这种重导出的做法是必要的，它可以分离虚拟模块和真实模块，因为真实模块可以通过相对地址来引入。如果不这么做，Esbuild 将会对打包输出两个一样的模块。</p>
</blockquote>
<p>刚开始看的确不太容易理解，接下来我会通过对比的方式来告诉你这种设计到底解决了什么问题。</p>
<p>假设我不像源码中这么做，在虚拟模块中直接将<strong>真实入口的内容</strong>作为传给 Esbuild 可不可以呢？也就是像这样:</p>
<pre><code class="hljs language-ts">build.<span class="hljs-title function_">onLoad</span>({ <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/.*/</span>, <span class="hljs-attr">namespace</span>: <span class="hljs-string">'dep'</span> }, <span class="hljs-function">(<span class="hljs-params">{ path: id }</span>) =></span> {
  <span class="hljs-comment">// 拿到查表拿到真实入口模块路径</span>
  <span class="hljs-keyword">const</span> entryFile = qualified[id];
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">loader</span>: <span class="hljs-string">'js'</span>,
    <span class="hljs-attr">contents</span>: fs.<span class="hljs-title function_">readFileSync</span>(entryFile, <span class="hljs-string">'utf8'</span>);
  }
}
</code></pre>
<p>那么，这么实现会产生什么问题呢？我们可以先看看正常的预打包流程（以 React 为例）:</p>
<p><img src="img\c8668e4d-ae61-11ed-b58c-342eb7027b95.jpg" alt=""></p>
<p>Vite 会使用 <code>dep:react</code>这个代理模块来作为入口内容在 Esbuild 中进行加载，与此同时，其他库的预打包也有可能会引入 React，比如<code>@emotion/react</code>这个库里面会有<code>require('react')</code>的行为。那么在 Esbuild 打包之后，<code>react.js</code>与<code>@emotion_react.js</code>的代码中会引用同一份 Chunk 的内容，这份 Chunk 也就对应 React 入口文件(<code>node_modules/react/index.js</code>)。</p>
<p>这是理想情况下的打包结果，接下来我们来看看上述有问题的版本是如何工作的:</p>
<p><img src="img\c887f71d-ae61-11ed-b46c-342eb7027b95.jpg" alt=""></p>
<p>现在如果代理模块通过文件系统直接读取真实模块的内容，而不是进行重导出，因此由于此时代理模块跟真实模块并没有任何的引用关系，这就导致最后的<code>react.js</code>和<code>@emotion/react.js</code>两份产物并不会引用同一份 Chunk，Esbuild 最后打包出了内容完全相同的两个 Chunk！</p>
<p>这也就能解释为什么 Vite 中要在代理模块中对真实模块的内容进行重导出了，主要是为了避免 Esbuild 产生重复的打包内容。此时，你是不是也恍然大悟了呢？</p>
<h2>小结</h2>
<p>本文的正文内容到此就接近尾声了，我们终于学习完了 Esbuild 预构建的底层实现，在这一节中，我首先带你熟悉一遍预构建的核心流程，包括<strong>缓存判断</strong>、<strong>依赖扫描</strong>、<strong>依赖打包</strong>和<strong>元信息写入磁盘</strong>这四个主要的步骤，让你从宏观上对 Vite 预构建流程有了初步的认识。</p>
<p>从微观的实现层面，我带你深入分析了<code>依赖扫描</code>的具体实现，从三个角度梳理了依赖扫描要解决的三个问题，分别是<code>如何获取入口</code>、<code>如何记录依赖</code> 以及 <code>如何制定 external 的规则</code>，并且与你重点分析<code>scanImports</code>函数的实现。接着我们继续深入到<code>依赖打包</code>的源码实现，带你了解到 Vite 是如何通过<code>嵌套路径扁平化</code> 和<code>代理模块</code>最终达到了扁平化的预构建产物结构，然后重点带你剖析了<code>代理模块</code>背后的设计原因，如果不这么做会产生什么问题，让你不仅知其然，同时也知其所以然。</p>
<p>相信经历过这一节的内容，你已经对 Vite 的预构建有了更加深刻的理解，也恭喜你，拿下了这一块困难而又深度的内容，我们下节再见。</p>
</div>
</body>
</html>