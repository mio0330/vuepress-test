<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!--    <title>Title</title>-->
    <style>
        body {
    font-family: -apple-system, system-ui, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial !important;
}

.markdown-body {
    word-break: break-word;
    line-height: 1.75;
    font-weight: 400;
    font-size: 16px;
    overflow-x: hidden;
    color: #333
}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    line-height: 1.5;
    margin-top: 35px;
    margin-bottom: 10px;
    padding-bottom: 5px
}

.markdown-body h1 {
    font-size: 24px;
    margin-bottom: 5px
}

.markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    font-size: 20px
}

.markdown-body h2 {
    padding-bottom: 12px;
    border-bottom: 1px solid #ececec
}

.markdown-body h3 {
    font-size: 18px;
    padding-bottom: 0
}

.markdown-body h6 {
    margin-top: 5px
}

.markdown-body p {
    line-height: inherit;
    margin-top: 22px;
    margin-bottom: 22px
}

.markdown-body img {
    max-width: 100%
}

.markdown-body hr {
    border: none;
    border-top: 1px solid #ddd;
    margin-top: 32px;
    margin-bottom: 32px
}

.markdown-body code {
    word-break: break-word;
    border-radius: 2px;
    overflow-x: auto;
    background-color: #fff5f5;
    color: #ff502c;
    font-size: .87em;
    padding: .065em .4em
}

.markdown-body code, .markdown-body pre {
    font-family: Menlo, Monaco, Consolas, Courier New, monospace
}

.markdown-body pre {
    overflow: auto;
    position: relative;
    line-height: 1.75
}

.markdown-body pre > code {
    font-size: 12px;
    padding: 15px 12px;
    margin: 0;
    word-break: normal;
    display: block;
    overflow-x: auto;
    color: #333;
    background: #f8f8f8
}

.markdown-body a {
    text-decoration: none;
    color: #0269c8;
    border-bottom: 1px solid #d1e9ff
}

.markdown-body a:active, .markdown-body a:hover {
    color: #275b8c
}

.markdown-body table {
    display: inline-block !important;
    font-size: 12px;
    width: auto;
    max-width: 100%;
    overflow: auto;
    border: 1px solid #f6f6f6
}

.markdown-body thead {
    background: #f6f6f6;
    color: #000;
    text-align: left
}

.markdown-body tr:nth-child(2n) {
    background-color: #fcfcfc
}

.markdown-body td, .markdown-body th {
    padding: 12px 7px;
    line-height: 24px
}

.markdown-body td {
    min-width: 120px
}

.markdown-body blockquote {
    color: #666;
    padding: 1px 23px;
    margin: 22px 0;
    border-left: 4px solid #cbcbcb;
    background-color: #f8f8f8
}

.markdown-body blockquote:after {
    display: block;
    content: ""
}

.markdown-body blockquote > p {
    margin: 10px 0
}

.markdown-body ol, .markdown-body ul {
    padding-left: 28px
}

.markdown-body ol li, .markdown-body ul li {
    margin-bottom: 0;
    list-style: inherit
}

.markdown-body ol li .task-list-item, .markdown-body ul li .task-list-item {
    list-style: none
}

.markdown-body ol li .task-list-item ol, .markdown-body ol li .task-list-item ul, .markdown-body ul li .task-list-item ol, .markdown-body ul li .task-list-item ul {
    margin-top: 0
}

.markdown-body ol ol, .markdown-body ol ul, .markdown-body ul ol, .markdown-body ul ul {
    margin-top: 3px
}

.markdown-body ol li {
    padding-left: 6px
}

.markdown-body .contains-task-list {
    padding-left: 0
}

.markdown-body .task-list-item {
    list-style: none
}

@media (max-width: 720px) {
    .markdown-body h1 {
        font-size: 24px
    }

    .markdown-body h2 {
        font-size: 20px
    }

    .markdown-body h3 {
        font-size: 18px
    }
}
    </style>
</head>
<body>
<div class="markdown-body">
    <p>当下，在项目开发的过程中，前端工程师们越来越离不开构建工具了，可以说<strong>构建工具已经成为了前端工程项目的标配。</strong></p>
<p>不过，如今的前端构建工具可谓<code>乱花渐欲迷人眼</code>，有远古时代的<code>browserify</code>、<code>grunt</code>，有传统的<code>Webpack</code>、<code>Rollup</code>、<code>Parcel</code>，也有现代的<code>Esbuild</code>、<code>Vite</code> 等等，不仅种类繁多，更新也很快。</p>
<p>于是，很多朋友会问我，到底哪个构建工具更好用、值得学。事实上，<strong>无论工具层面如何更新，它们解决的核心问题，即前端工程的痛点是不变的</strong>。因此，想要知道哪个工具更好用，就要看它解决前端工程痛点的效果。</p>
<p>那么，前端工程都有哪些痛点呢？</p>
<p>首先是前端的<strong>模块化需求</strong>。我们知道，业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。</p>
<p>其次是<strong>兼容浏览器，编译高级语法</strong>。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。</p>
<p>再者是<strong>线上代码的质量</strong>问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的<code>安全性</code>、<code>兼容性</code>问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。</p>
<p>同时，<code>开发效率</code><strong>也不容忽视。</strong> 我们知道，<strong>项目的冷启动/二次启动时间</strong>、<strong>热更新时间</strong>都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。</p>
<p>那么，前端构建工具是如何解决以上问题的呢？</p>
<p><img src="img\b1513bcf-ae61-11ed-8f3c-342eb7027b95.jpg" alt=""></p>
<ul>
<li>
<p>模块化方面，提供模块加载方案，并兼容不同的模块规范。</p>
</li>
<li>
<p>语法转译方面，配合 <code>Sass</code>、<code>TSC</code>、<code>Babel</code> 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。</p>
</li>
<li>
<p>产物质量方面，在生产环境中，配合 <code>Terser</code>等压缩工具进行代码压缩和混淆，通过 <code>Tree Shaking</code> 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。</p>
</li>
<li>
<p>开发效率方面，构建工具本身通过各种方式来进行性能优化，包括<code>使用原生语言 Go/Rust</code>、<code>no-bundle</code>等等思路，提高项目的启动性能和热更新的速度。</p>
</li>
</ul>
<h2>为什么 Vite 是当前最高效的构建工具？</h2>
<p>现在，让我们回到一开始提出的问题，到底哪个工具更好用？或者说，哪个工具解决前端工程痛点的效果更好？</p>
<p>The State of JavaScript Survey 最近的调查结果中显示， Vite 在全球开发者中的满意度超过 98%，已经被用到了<code>SvelteKit</code>、<code>Astro</code>这些大型框架中，成为当下最受瞩目的前端构建工具。我也最推荐你使用它。为什么是 Vite 呢？我们可以根据上面说的四个维度来审视它。</p>
<p>首先是开发效率。传统构建工具普遍的缺点就是太慢了，与之相比，Vite 能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。</p>
<p>就拿 Webpack 来说，我在工作中发现，一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为：</p>
<ul>
<li>项目冷启动时必须递归打包整个项目的依赖树</li>
<li>JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率</li>
</ul>
<p>这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。而其中，最占用时间的就是代码打包和文件编译。</p>
<p>而 Vite 很好地解决了这些问题。一方面，Vite 在开发阶段基于浏览器原生 ESM 的支持实现了<code>no-bundle</code>服务，另一方面借助 Esbuild 超快的编译速度来做第三方库构建和 TS/JSX 语法编译，从而能够有效提高开发效率。</p>
<p>除了开发效率，在其他三个维度上， Vite 也表现不俗。</p>
<ul>
<li>
<p>模块化方面，Vite 基于浏览器原生 ESM 的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式的产物(如 CommonJS)转换为 ESM。</p>
</li>
<li>
<p>语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。</p>
</li>
<li>
<p>产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合<code>Terser</code>、<code>Babel</code>等工具链，可以极大程度保证构建产物的质量。</p>
</li>
</ul>
<p>因此，如果你想要学习一个前端构建工具，Vite 将会是你当下一个最好的选择。它不仅解决了传统构建工具的开发效率问题，而且具备一个优秀构建工具的各项要素，还经历了社区大规模的验证与落地。</p>
<h2>如何才能学好 Vite ？</h2>
<p>不过，很多人在学习和应用 Vite 的过程中总会遇到各种各样的问题。</p>
<p>比如说，很多 Vite 学习资料既不系统，也不深入。绝大多数的文章只能教会我们如何搭建一个简单的脚手架项目，甚至代码都不一定正确。</p>
<p>即使通过资料学完了 Vite 的相关知识，但因为对 Vite 的生态了解不够，遇到实际问题的时候依然不知道要使用哪些插件或者解决方案。</p>
<ul>
<li>第三方库里面含有 CommonJS 代码导致报错了怎么办?</li>
<li>想在开发过程中进行 Eslint 代码规范检查怎么办？</li>
<li>生产环境打包项目后，如何产出构建产物分析报告？</li>
<li>如果要兼容不支持原生 ESM 的浏览器，怎么办？</li>
</ul>
<p>而且，如果你对 Vite 底层使用的构建引擎 Esbuild 和 Rollup 不够熟悉，遇到一些需要定制的场景，往往也会捉襟见肘。</p>
<ul>
<li>写一个 Esbuild 插件来处理一下问题依赖</li>
<li>对于 Rollup 打包产物进行自定义拆包，解决实际场景中经常出现的循环依赖问题</li>
<li>使用 Esbuild 的代码转译和压缩功能会出现哪些兼容性问题？如何解决？</li>
</ul>
<p>当然，作为一个构建工具，Vite 的难点不仅在于它本身的灵活性，也包含了诸如<code>Babel</code>、<code>core-js</code> 等诸多前端工具链的集成和应用。</p>
<ul>
<li><code>@babel/preset-env</code> 的 <code>useBuiltIns</code> 属性各个取值有哪些区别？</li>
<li><code>@babel/polyfill</code> 与 <code>@babel/runtime-corejs</code> 有什么区别？</li>
<li><code>@babel/plugin-transform-runtime</code> 与<code>@babel/preset-env</code> 的 <code>useBuiltIn</code> 相比有什么优化？</li>
<li>core-js 的作用是什么？其产物有哪些版本？<code>core-js</code> 和 <code>core-js-pure</code> 有什么区别？</li>
</ul>
<p>此外，由于构建工具(不仅包括 Vite，也包括底层引擎 Rollup)的源码晦涩难懂，涉及大量的基础工具库，导致很多人对构建工具原理的理解只浮于表面，很难更进一步。</p>
<p>作为一名深耕在一线的前端工程师，我的日常工作就是跟各种构建工具打交道，在公司中诸多的业务项目中落地了 Vite，有丰富的 Vite 实战经验和源码阅读经验，也给 Vite 仓库贡献过一些代码。因此，我也非常乐意将自己在 Vite 方面的实战经验与学习方法通过小册系统性地分享给大家。</p>
<p><img src="img\b16b65ee-ae61-11ed-abfb-342eb7027b95.jpg" alt="20220323稀土掘金-「小册」《深入浅出 Vite 》视觉延展 - 改1_作者简介.jpg"></p>
<p>那么， Vite 该如何学习呢？我按照<strong>循序渐进、可实操、可延伸</strong>的三个原则，由浅入深设计课程内容，提供大量的实战场景和案例，同时尽可能给大家提供解决问题的方法和视角，让大家学完课程后能做到举一反三。具体来说，我将课程设计为 5 个模块。</p>
<p><strong>在基础使用篇中</strong>，我将与你从 0 开始实现 Vite 项目初始化，接入各种现代化的 CSS 方案，集成 Eslint、Styelint、Commonlint 等一系列 Lint 工具链，处理各种形式的静态资源，掌握 Vite 预编译的各种使用技巧，最终让你能独立搭建一个相对完整的脚手架工程。</p>
<p><strong>在双引擎篇中</strong>，我们会学习 Vite 的双引擎架构， Esbuild 和 Rollup 相关的内容，包括它们的基本使用和插件开发，掌握<code>最小必要知识</code>，为后续的高级应用作铺垫。</p>
<p><strong>而高级应用篇</strong>， 我们将学习 Vite 的各种高级用法和构建性能优化手段，学会如何编写一个完整的 Vite 插件，熟练进行生产环境拆包，使用 Vite 搭建复杂的 SSR 工程，实现基于模块联邦的跨应用模块共享架构。不管是项目性能优化技巧，还是对前端底层标准和规范的理解，你都会从这一模块得到不少提升。</p>
<p>接下来，我们将一起剖析 <strong>Vite</strong> <strong>的核心源码</strong>，理解诸如<code>JIT</code>、<code>Proxy Module</code>、<code>Module Graph</code>、<code>HMR Boundary</code>和<code>Plugin Container</code> 等源码中重要概念的作用及底层实现，一步步教你学会阅读 Vite 的源码，将如下架构图中的关键环节各个击破，学透 Vite 实现原理。</p>
<p><img src="img\b19608bb-ae61-11ed-898d-342eb7027b95.jpg" alt="image.png"></p>
<p><strong>最后是手写实战篇。</strong> 首先，我们会手写 Vite 的开发时 no-bundle 服务，也就是开发环境下基于浏览器原生 ESM 的 Dev Server。然后，我也会带你一步步完成一个生产环境打包工具（Bundler），从 AST 解析的功能开始，完成代码的词法分析（tokenize）和语义分析（parse），实现模块依赖图和作用域链的搭建，并完成 Tree Shaking、循环依赖检测及 Bundle 代码生成，最终实现一个类似 Rollup 的 Bundler。</p>
<p><img src="img\b1ab1732-ae61-11ed-b127-342eb7027b95.jpg" alt="深入浅出 Vite (2).png"></p>
<p>可以看到，我们在课程中非常重视上手实战。课程的代码全部会上传至 Github 仓库(<a href="https://github.com/sanyuan0704/juejin-book-vite" target="_blank" rel="nofollow noopener noreferrer">仓库地址</a>)，基本上每一节内容都有能 run 起来的代码案例。尤其在最后一章，为了让你理解构建工具的底层原理，我会带你一步步搭建一个简单的构建工具，进行上千行代码的手写实战，做到真正的代码可实操。</p>
<p>最后，我希望在这本小册中，我们能一起深入 Vite 的实战要点和实现原理 ，领略前端工程化构建领域的底层风光，真正实现 Vite 从入门到进阶！</p>
</div>
</body>
</html>